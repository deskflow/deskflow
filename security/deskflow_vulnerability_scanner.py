#!/usr/bin/env python3
import socket
import time
import random
import string
import base64
import binascii
import re
import argparse
import concurrent.futures
import ssl
import struct
import os
from collections import defaultdict


def generate_randstr(n):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=n))


def perform_test(host, port, input_data, read_size, timeout=5):
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            s.sendall(input_data.encode())
            start = time.time()
            resp = s.recv(read_size)
            elapsed = time.time() - start
        return resp, elapsed
    except Exception as e:
        return None, None


def session_scan(host, use_ssl=False):
    print("\nRunning Deskflow Session Scan")
    test_inputs = [
        "CL:Unnamed\nHANDSHAKE:1",
        "CL:localhost\nHANDSHAKE:1", 
        "CL:desktop\nHANDSHAKE:1",
        "CL:workstation\nHANDSHAKE:1"
    ]
    
    successful_handshakes = []
    
    for data in test_inputs:
        resp, elapsed = perform_test(host, 24800, data, 256)
        if resp:
            resp_text = resp.decode('utf-8', errors='ignore')
            
            session_keywords = ["QSINIT:1", "CSINIT:1", "NONE", "CORE"]
            version_match = re.search(r'Deskflow v([0-9]+\.[0-9]+\.[0-9]+)', resp_text)
            
            if any(word in resp_text for word in session_keywords):
                successful_handshakes.append(data)
                
                if version_match:
                    version = version_match.group(1)
                    if version.split('.') < ['2', '4', '0']:
                        print(f"Critical Vulnerability: Server {version} accepted session handshake for {data}")
                        print("This version is vulnerable to session bypass attacks")
                    else:
                        print(f"Session handshake accepted but server version {version} is not vulnerable")
                else:
                    print(f"Warning: Session handshake accepted for {data} but version could not be determined")
                    
                if "150300020216" in resp_text:
                    print(f"Warning: Unexpected binary protocol response detected for {data}")
            else:
                print(f"Session handshake rejected for {data} (expected)")
        else:
            print(f"No response received for {data} - connection refused or timed out")
    
    if len(successful_handshakes) > 0:
        print("\nVulnerability Summary:")
        print(f"Successfully established {len(successful_handshakes)} unauthorized sessions")
        print("Affected client labels:")
        for handshake in successful_handshakes:
            print(f" - {handshake.split('\n')[0]}")
    else:
        print("\nNo session vulnerabilities detected - all handshakes were properly rejected")


def memory_scan(host, use_ssl=False):
    print("\nRunning Deskflow Memory Exhaustion Scan")
    payload = f"DESKFLOW_TEST_MEMORY_EXHAUSTION_PAYLOAD_{generate_randstr(1024)}_{generate_randstr(1024)}_{generate_randstr(1024)}"
    large_payload = "A" * 1048576
    for data in [payload, large_payload]:
        resp, elapsed = perform_test(host, 24800, data, 2048, timeout=10)
        if resp:
            resp_text = resp.decode('utf-8', errors='ignore')
            if elapsed is not None and elapsed >= 5:
                print(f"Memory Scan: Slow response ({elapsed:.2f}s) detected for payload length {len(data)}")
            if resp_text == "":
                print("Memory Scan: Empty response received.")
            if "out of memory" in resp_text or "memory allocation failed" in resp_text:
                print("Memory Scan: Server reported memory issues.")
        else:
            print(f"Memory Scan Error: No response for payload length {len(data)}")


def descriptor_scan(host, use_ssl=False):
    print("\nRunning Enhanced Deskflow File Descriptor Exhaustion Scan")
    persistent_connections = []
    max_connections = 200
    print(f"Opening up to {max_connections} persistent connections.")
    for i in range(max_connections):
        try:
            s = socket.create_connection((host, 24800), timeout=5)
            message = f"CONNECT:{'A'*1024}\nCLIENT:stress_{i}"
            s.sendall(message.encode())
            persistent_connections.append(s)
            print(f"Opened persistent connection {i+1}")
        except Exception as e:
            print(f"Failed to open persistent connection {i+1}: {e}")
            break
    print(f"Total persistent connections opened: {len(persistent_connections)}")
    try:
        extra = socket.create_connection((host, 24800), timeout=5)
        extra.close()
        print("Extra connection succeeded: Server appears to be handling connections properly.")
    except Exception as e:
        if "Too many" in str(e) or "file descriptor" in str(e) or "EMFILE" in str(e):
            print("Extra connection failed: File descriptors exhausted. Vulnerability likely present.")
        else:
            print(f"Extra connection failed with error: {e}")
    for s in persistent_connections:
        try:
            s.close()
        except:
            pass


def connection_scan(host, use_ssl=False):
    print("\nRunning Deskflow Connection Flood Vulnerability Scan")
    
    def send_hello(i):
        message = "HELLO:" + generate_randstr(32) + "\nQUIT"
        resp, elapsed = perform_test(host, 24800, message, 256)
        return (i, resp, elapsed, message)
        
    num_requests = 100
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        futures = [executor.submit(send_hello, i) for i in range(num_requests)]
        for future in concurrent.futures.as_completed(futures):
            i, resp, elapsed, message = future.result()
            if resp:
                resp_text = resp.decode('utf-8', errors='ignore')
                error_words = ["Segmentation fault", "SIGSEGV", "core dumped", "stack overflow", "memory corruption", "connection reset"]
                if any(w in resp_text for w in error_words):
                    print(f"Connection Scan: Vulnerability detected in request {i} with message: {message}")
                else:
                    print(f"Connection Scan: Request {i} did not trigger vulnerability.")
            else:
                print(f"Connection Scan: Request {i} received no response.")

def client_verification_scan(host, use_ssl=False):
    print("\nRunning Deskflow Client Verification Vulnerability Scan")
    tests = [
        {
            "data": f"CONNECT:{generate_randstr(32)}\nVERIFY:{generate_randstr(64)}\nCLIENT:test_client",
            "expected": "reject",
            "description": "Random invalid token"
        },
        {
            "data": f"CONNECT:{base64.b64encode(b'test_client').decode()}\nVERIFY:{base64.b64encode(b'invalid_token').decode()}\nCLIENT:test_client",
            "expected": "reject",
            "description": "Base64 encoded invalid token"
        },
        {
            "data": f"CONNECT:{base64.b64encode(b'system').decode()}\nVERIFY:{base64.b64encode(('system:' + generate_randstr(32)).encode()).decode()}\nCLIENT:system",
            "expected": "reject",
            "description": "System client with invalid token format"
        }
    ]
    
    auth_patterns = {
        "accept": [r"AUTH[_\-]?OK", r"VERIFIED", r"SUCCESS", r"CONNECTED", r"ACCEPT"],
        "reject": [
            r"AUTH[_\-]?FAIL",
            r"REJECTED",
            r"INVALID[_\-]?TOKEN",
            r"ERROR",
            r"DENIED",
            r"UNAUTHORIZED",
            r"FORBIDDEN",
            r"ACCESS[_\-]?DENIED",
            r"BAD[_\-]?REQUEST",
            r"FAILED",
            r"INVALID",
            r"\s*$"
        ]
    }
    
    for test in tests:
        data = test["data"]
        expected = test["expected"]
        description = test["description"]
        
        print(f"\nRunning test: {description}")
        resp, elapsed = perform_test(host, 24800, data, 1024)
        
        if resp:
            resp_text = resp.decode('utf-8', errors='ignore').strip()
            
            accepted = any(re.search(pattern, resp_text, re.IGNORECASE) for pattern in auth_patterns["accept"])
            rejected = any(re.search(pattern, resp_text, re.IGNORECASE) for pattern in auth_patterns["reject"])
            
            if not resp_text:
                print(f"Empty response received - treating as rejection for {description}")
                rejected = True
            
            if expected == "reject":
                if accepted:
                    print(f"Vulnerability Detected: Server incorrectly accepted {description}")
                    print(f"Response: {resp_text}")
                elif rejected:
                    print(f"Security Check Passed: Server correctly rejected {description}")
                    if resp_text:
                        print(f"Response: {resp_text}")
                else:
                    print(f"Inconclusive Result: Unexpected response pattern for {description}")
                    print(f"Response: {resp_text}")
            else:
                if accepted:
                    print(f"Security Check Passed: Server correctly accepted {description}")
                    print(f"Response: {resp_text}")
                elif rejected:
                    print(f"Potential Issue: Server incorrectly rejected {description}")
                    print(f"Response: {resp_text}")
                else:
                    print(f"Inconclusive Result: Unexpected response pattern for {description}")
                    print(f"Response: {resp_text}")
        else:
            print(f"Security Check Passed: Server rejected {description} by closing connection")


def tls_handshake_fuzzing(host, port=24800):
    print("\nRunning TLS Handshake Fuzzing")
    
    def create_malformed_client_hello(fuzzing_type):
        versions = [
            b'\x03\x00',  # SSL 3.0
            b'\x03\x01',  # TLS 1.0
            b'\x03\x02',  # TLS 1.1
            b'\x03\x03',  # TLS 1.2
            b'\x03\x04',  # TLS 1.3
            b'\x00\x00',  # Invalid version
            b'\xFF\xFF',  # Invalid version
        ]
        
        if fuzzing_type == "version":
            for version in versions:
                yield (
                    b'\x16' +  # Handshake type
                    version +  # Protocol version
                    b'\x00\x2F' +  # Length
                    b'\x01' +  # Client Hello
                    b'\x00\x00\x2B' +  # Handshake length
                    version +  # Client version
                    os.urandom(32)  # Random padding
                )
        elif fuzzing_type == "length":
            lengths = [b'\x00\x00', b'\xFF\xFF', b'\x00\x01']
            for length in lengths:
                yield (
                    b'\x16' +  # Handshake type
                    b'\x03\x03' +  # TLS 1.2
                    length +  # Malformed length
                    os.urandom(32)  # Random padding
                )
        elif fuzzing_type == "content":
            yield b'\x16' + b'\x03\x03' + b'\x00\x2F' + b'A' * 1024  # Overflow
            yield b'\x16' + b'\x03\x03' + b'\x00\x2F' + b''  # Empty
            yield b'\x16' + b'\x03\x03' + b'\x00\x2F' + b'\x00' * 1024  # Null bytes
    
    fuzzing_types = ["version", "length", "content"]
    vulnerabilities = defaultdict(list)
    
    for fuzz_type in fuzzing_types:
        print(f"\nTesting {fuzz_type} fuzzing:")
        for payload in create_malformed_client_hello(fuzz_type):
            try:
                with socket.create_connection((host, port), timeout=5) as sock:
                    sock.send(payload)
                    try:
                        response = sock.recv(1024)
                        if response:
                            if response[0] == 0x15:
                                alert_level = response[1] if len(response) > 1 else None
                                alert_description = response[2] if len(response) > 2 else None
                                
                                if alert_level == 2:
                                    print(f"[+] Server properly rejected malformed {fuzz_type} with fatal alert")
                                elif alert_level == 1:
                                    print(f"[!] Server sent warning for malformed {fuzz_type} - potential vulnerability")
                                    vulnerabilities[fuzz_type].append("Warning instead of fatal alert")
                            else:
                                print(f"[!] Server accepted malformed {fuzz_type} - vulnerability detected")
                                vulnerabilities[fuzz_type].append("Accepted malformed data")
                    except socket.timeout:
                        print(f"[+] Server timeout on malformed {fuzz_type} - likely rejected")
            except ConnectionResetError:
                print(f"[+] Server actively rejected malformed {fuzz_type}")
            except Exception as e:
                if "Connection refused" in str(e):
                    print(f"[+] Server refused connection for malformed {fuzz_type}")
                else:
                    print(f"[-] Error during {fuzz_type} test: {e}")

    if not vulnerabilities:
        print("\n[+] No TLS handshake vulnerabilities detected")
    else:
        print("\n[-] TLS handshake vulnerabilities found:")
        for fuzz_type, issues in vulnerabilities.items():
            for issue in issues:
                print(f"  - {fuzz_type}: {issue}")

    return vulnerabilities

def check_tls_vulnerabilities(host, port=24800):
    print("\nChecking for Known TLS Vulnerabilities")
    
    def test_cipher_suite(sock, cipher_suite):
        context = ssl.create_default_context()
        context.set_ciphers(cipher_suite)
        try:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                cipher_info = ssock.cipher()
                if cipher_info:
                    return True, cipher_info
                return False, None
        except (ssl.SSLError, ssl.SSLEOFError) as e:
            if "protocol version" in str(e):
                return False, "Protocol version not supported"
            elif "handshake failure" in str(e):
                return False, "Handshake failed - cipher likely not supported"
            return False, str(e)
        except Exception as e:
            return False, f"Unexpected error: {str(e)}"
        
    weak_ciphers = [
        'NULL', 'aNULL', 'EXPORT', 'RC4', 'DES', '3DES', 'MD5', 'PSK',
        'SRP', 'DSS', 'IDEA', 'SEED', 'ARIA'
    ]
    
    vulnerabilities = []
    
    for cipher in weak_ciphers:
        try:
            sock = socket.create_connection((host, port), timeout=5)
            supported, info = test_cipher_suite(sock, cipher)
            if supported:
                vulnerabilities.append(f"Weak cipher supported: {cipher} - {info}")
            else:
                print(f"[+] Cipher {cipher} not supported: {info}")
        except socket.timeout:
            print(f"[+] Connection timeout testing cipher {cipher} - likely rejected")
        except ConnectionRefusedError:
            print(f"[+] Connection refused for cipher {cipher} - port may be closed")
        except Exception as e:
            print(f"[-] Error testing cipher {cipher}: {e}")
        finally:
            try:
                sock.close()
            except:
                pass
            
    return vulnerabilities

def test_mitm_vulnerability(host, port=24800):
    print("\nTesting for MITM Vulnerabilities")
    
    def create_downgrade_hello(version):
        return (
            b'\x16' +  # Handshake
            version +  # Protocol version
            b'\x00\x2F' +  # Length
            b'\x01' +  # ClientHello
            b'\x00\x00\x2B' +  # Hello Length
            version +  # Client version
            os.urandom(32)  # Random data
        )
    
    vulnerabilities = []
    test_versions = [
        (b'\x03\x00', "SSL 3.0"),  # SSL 3.0
        (b'\x03\x01', "TLS 1.0"),  # TLS 1.0
        (b'\x02\x00', "SSL 2.0"),  # SSL 2.0
        (b'\x00\xFF', "Invalid Version")  # Invalid version
    ]
    
    for version, version_name in test_versions:
        try:
            with socket.create_connection((host, port), timeout=5) as sock:
                sock.send(create_downgrade_hello(version))
                try:
                    response = sock.recv(1024)
                    if response:
                        if response[0] == 0x15:
                            alert_level = response[1] if len(response) > 1 else None
                            if alert_level == 2:
                                print(f"[+] Server properly rejected downgrade to {version_name}")
                            else:
                                print(f"[!] Server sent non-fatal alert for {version_name} - potential vulnerability")
                                vulnerabilities.append(f"Non-fatal alert for {version_name} downgrade attempt")
                        elif version in response:
                            print(f"[!] Server accepted downgrade to {version_name} - vulnerability detected")
                            vulnerabilities.append(f"Server accepts downgrade to {version_name}")
                        else:
                            print(f"[?] Unexpected response format for {version_name}")
                except socket.timeout:
                    print(f"[+] Server timeout on {version_name} - likely rejected")
                except ConnectionResetError:
                    print(f"[+] Server actively rejected {version_name} downgrade attempt")
        except socket.timeout:
            print(f"[+] Connection timeout for {version_name} test - likely rejected")
        except ConnectionRefusedError:
            print(f"[+] Connection refused for {version_name} test - port may be closed")
        except Exception as e:
            print(f"[-] Error testing {version_name}: {e}")
            
    return vulnerabilities

def check_timing_attacks(host, port=24800):
    print("\nChecking for Timing Attack Vulnerabilities")
    
    def measure_response_time(payload, num_samples=5):
        times = []
        for _ in range(num_samples):
            try:
                start = time.time()
                with socket.create_connection((host, port), timeout=5) as sock:
                    sock.send(payload)
                    sock.recv(1024)
                elapsed = time.time() - start
                times.append(elapsed)
                time.sleep(0.1)
            except (socket.timeout, ConnectionResetError):
                continue
            except Exception:
                continue
        return times if times else None
    
    timing_samples = defaultdict(list)
    test_cases = {
        "valid_cert": b'\x16\x03\x03' + struct.pack('>H', 32) + os.urandom(32),
        "invalid_cert": b'\x16\x03\x03' + struct.pack('>H', 32) + b'\x00' * 32
    }
    
    for case_name, payload in test_cases.items():
        times = measure_response_time(payload)
        if times:
            timing_samples[case_name].extend(times)
    
    vulnerabilities = []
    if timing_samples["valid_cert"] and timing_samples["invalid_cert"]:
        avg_valid = sum(timing_samples["valid_cert"]) / len(timing_samples["valid_cert"])
        avg_invalid = sum(timing_samples["invalid_cert"]) / len(timing_samples["invalid_cert"])
        std_valid = (sum((x - avg_valid) ** 2 for x in timing_samples["valid_cert"]) / len(timing_samples["valid_cert"])) ** 0.5
        std_invalid = (sum((x - avg_invalid) ** 2 for x in timing_samples["invalid_cert"]) / len(timing_samples["invalid_cert"])) ** 0.5
        
        if abs(avg_valid - avg_invalid) > 3 * (std_valid + std_invalid) / 2:
            vulnerabilities.append(
                f"Potential timing side-channel detected:\n" \
                f"  - Valid cert avg: {avg_valid:.3f}s (std: {std_valid:.3f}s)\n" \
                f"  - Invalid cert avg: {avg_invalid:.3f}s (std: {std_invalid:.3f}s)"
            )
        else:
            print("[+] No significant timing differences detected")
            
    return vulnerabilities

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Deskflow Vulnerability Scanner')
    parser.add_argument('hostname', help='Target hostname or IP')
    parser.add_argument('--use-ssl', action='store_true', help='Use SSL/TLS for connections')
    parser.add_argument('--port', type=int, default=24800, help='Target port (default: 24800)')
    args = parser.parse_args()
    
    host = args.hostname
    port = args.port
    print(f"Starting Deskflow Vulnerability Scans on {host} (port {port})")
    
    session_scan(host, use_ssl=args.use_ssl)
    memory_scan(host, use_ssl=args.use_ssl)
    descriptor_scan(host, use_ssl=args.use_ssl)
    connection_scan(host, use_ssl=args.use_ssl)
    client_verification_scan(host, use_ssl=args.use_ssl)
    
    if args.use_ssl:
        print("\n=== Starting TLS-specific Security Scans ===")
        
        handshake_vulns = tls_handshake_fuzzing(host, port)
        if handshake_vulns:
            print("\nHandshake Fuzzing Vulnerabilities:")
            for fuzz_type, issues in handshake_vulns.items():
                for issue in issues:
                    print(f"- {fuzz_type}: {issue}")
        
        tls_vulns = check_tls_vulnerabilities(host, port)
        if tls_vulns:
            print("\nTLS Protocol Vulnerabilities:")
            for vuln in tls_vulns:
                print(f"- {vuln}")
        
        mitm_vulns = test_mitm_vulnerability(host, port)
        if mitm_vulns:
            print("\nMITM Vulnerabilities:")
            for vuln in mitm_vulns:
                print(f"- {vuln}")
        
        timing_vulns = check_timing_attacks(host, port)
        if timing_vulns:
            print("\nTiming Attack Vulnerabilities:")
            for vuln in timing_vulns:
                print(f"- {vuln}")
