cmake version 2.8.0
------------------------------------------------------------------------------
Introduction

cmake-modules - Reference of available CMake modules.

------------------------------------------------------------------------------
Description

The "cmake" executable is the CMake command-line interface.  It may be used
to configure projects in scripts.  Project configuration settings may be
specified on the command line with the -D option.  The -i option will cause
cmake to interactively prompt for such settings.

CMake is a cross-platform build system generator.  Projects specify their
build process with platform-independent CMake listfiles included in each
directory of a source tree with the name CMakeLists.txt.  Users build a
project by using CMake to generate a build system for a native tool on their
platform.

------------------------------------------------------------------------------
Standard CMake Modules

The following modules are provided with CMake.  They can be used with
INCLUDE(ModuleName).

  CMake Modules - Modules coming with CMake, the Cross-Platform Makefile Generator.

This is the documentation for the modules and scripts coming with CMake.
Using these modules you can check the computer system for installed software
packages, features of the compiler and the existance of headers to name just
a few.

  AddFileDependencies
       ADD_FILE_DEPENDENCIES(source_file depend_files...)

       Adds the given files as dependencies to source_file


  BundleUtilities
        

       BundleUtilities.cmake

       A collection of CMake utility functions useful for dealing with .app
       bundles on the Mac and bundle-like directories on any OS.

       The following functions are provided by this script:

          get_bundle_main_executable
          get_dotapp_dir
          get_bundle_and_executable
          get_bundle_all_executables
          get_item_key
          clear_bundle_keys
          set_bundle_key_values
          get_bundle_keys
          copy_resolved_item_into_bundle
          fixup_bundle_item
          fixup_bundle
          copy_and_fixup_bundle
          verify_bundle_prerequisites
          verify_bundle_symlinks
          verify_app

       

       Requires CMake 2.6 or greater because it uses function, break and
       PARENT_SCOPE.  Also depends on GetPrerequisites.cmake.

  CMakeBackwardCompatibilityCXX
       define a bunch of backwards compatibility variables

         CMAKE_ANSI_CXXFLAGS - flag for ansi c++ 
         CMAKE_HAS_ANSI_STRING_STREAM - has <strstream>
         INCLUDE(TestForANSIStreamHeaders)
         INCLUDE(CheckIncludeFileCXX)
         INCLUDE(TestForSTDNamespace)
         INCLUDE(TestForANSIForScope)


  CMakeDependentOption
       Macro to provide an option dependent on other options.

       This macro presents an option to the user only if a set of other
       conditions are true.  When the option is not presented a default value
       is used, but any value set by the user is preserved for when the
       option is presented again.  Example invocation:

         CMAKE_DEPENDENT_OPTION(USE_FOO "Use Foo" ON
                                "USE_BAR;NOT USE_ZOT" OFF)

       If USE_BAR is true and USE_ZOT is false, this provides an option
       called USE_FOO that defaults to ON.  Otherwise, it sets USE_FOO to
       OFF.  If the status of USE_BAR or USE_ZOT ever changes, any value for
       the USE_FOO option is saved so that when the option is re-enabled it
       retains its old value.

  CMakeDetermineVSServicePack
       Includes a public function for assisting users in trying to determine
       the

       Visual Studio service pack in use.

       Sets the passed in variable to one of the following values or an empty
       string if unknown.

           vc80
           vc80sp1
           vc90
           vc90sp1

       

       Usage: ===========================

           if(MSVC)
              include(CMakeDetermineVSServicePack)
              DetermineVSServicePack( my_service_pack )

       

              if( my_service_pack )
                  message(STATUS "Detected: ${my_service_pack}")
              endif()
           endif()

       

       ===========================

  CMakeFindFrameworks
       helper module to find OSX frameworks

  CMakeForceCompiler
        

       This module defines macros intended for use by cross-compiling
       toolchain files when CMake is not able to automatically detect the
       compiler identification.

       Macro CMAKE_FORCE_C_COMPILER has the following signature:

          CMAKE_FORCE_C_COMPILER(<compiler> <compiler-id>)

       It sets CMAKE_C_COMPILER to the given compiler and the cmake internal
       variable CMAKE_C_COMPILER_ID to the given compiler-id.  It also
       bypasses the check for working compiler and basic compiler information
       tests.

       Macro CMAKE_FORCE_CXX_COMPILER has the following signature:

          CMAKE_FORCE_CXX_COMPILER(<compiler> <compiler-id>)

       It sets CMAKE_CXX_COMPILER to the given compiler and the cmake
       internal variable CMAKE_CXX_COMPILER_ID to the given compiler-id.  It
       also bypasses the check for working compiler and basic compiler
       information tests.

       So a simple toolchain file could look like this:

          INCLUDE (CMakeForceCompiler)
          SET(CMAKE_SYSTEM_NAME Generic)
          CMAKE_FORCE_C_COMPILER   (chc12 MetrowerksHicross)
          CMAKE_FORCE_CXX_COMPILER (chc12 MetrowerksHicross)


  CMakePrintSystemInformation
       print system information

       This file can be used for diagnostic purposes just include it in a
       project to see various internal CMake variables.

  CMakeVerifyManifest
        

       CMakeVerifyManifest.cmake

       This script is used to verify that embeded manifests and side by side
       manifests for a project match.  To run this script, cd to a directory
       and run the script with cmake -P.  On the command line you can pass in
       versions that are OK even if not found in the .manifest files.  For
       example, cmake -Dallow_versions=8.0.50608.0
       -PCmakeVerifyManifest.cmake could be used to allow an embeded manifest
       of 8.0.50608.0 to be used in a project even if that version was not
       found in the .manifest file.

  CPack
       Build binary and source package installers

       

       The CPack module generates binary and source installers in a variety
       of formats using the cpack program.  Inclusion of the CPack module
       adds two new targets to the resulting makefiles, package and
       package_source, which build the binary and source installers,
       respectively.  The generated binary installers contain everything
       installed via CMake's INSTALL command (and the deprecated
       INSTALL_FILES, INSTALL_PROGRAMS, and INSTALL_TARGETS commands).

       For certain kinds of binary installers (including the graphical
       installers on Mac OS X and Windows), CPack generates installers that
       allow users to select individual application components to install.
       The contents of each of the components are identified by the COMPONENT
       argument of CMake's INSTALL command.  These components can be
       annotated with user-friendly names and descriptions, inter-component
       dependencies, etc., and grouped in various ways to customize the
       resulting installer.  See the cpack_add_* commands, described below,
       for more information about component-specific installations.

       Before including the CPack module, there are a variety of variables
       that can be set to customize the resulting installers.  The most
       commonly-used variables are:

          CPACK_PACKAGE_NAME - The name of the package (or application). If
          not specified, defaults to the project name.

       

          CPACK_PACKAGE_VENDOR - The name of the package vendor (e.g.,
          "Kitware").

       

          CPACK_PACKAGE_VERSION_MAJOR - Package major Version

       

          CPACK_PACKAGE_VERSION_MINOR - Package minor Version

       

          CPACK_PACKAGE_VERSION_PATCH - Package patch Version

       

          CPACK_PACKAGE_DESCRIPTION_FILE - A text file used to describe the
          project. Used, for example, the introduction screen of a
          CPack-generated Windows installer to describe the project.

       

          CPACK_PACKAGE_DESCRIPTION_SUMMARY - Short description of the
          project (only a few words).

       

          CPACK_PACKAGE_FILE_NAME - The name of the package file to generate,
          not including the extension. For example, cmake-2.6.1-Linux-i686.

       

          CPACK_PACKAGE_INSTALL_DIRECTORY - Installation directory on the
          target system, e.g., "CMake 2.5".

       

          CPACK_RESOURCE_FILE_LICENSE - License file for the project, which
          will typically be displayed to the user (often with an explicit
          "Accept" button, for graphical installers) prior to installation.

       

          CPACK_RESOURCE_FILE_README - ReadMe file for the project, which
          typically describes in some detail

       

          CPACK_RESOURCE_FILE_WELCOME - Welcome file for the project, which
          welcomes users to this installer. Typically used in the graphical
          installers on Windows and Mac OS X.

       

          CPACK_MONOLITHIC_INSTALL - Disables the component-based 
          installation mechanism, so that all components are always installed.

       

          CPACK_GENERATOR - List of CPack generators to use. If not
          specified, CPack will create a set of options (e.g.,
          CPACK_BINARY_NSIS) allowing the user to enable/disable individual
          generators.

       

          CPACK_OUTPUT_CONFIG_FILE - The name of the CPack configuration file
          for binary installers that will be generated by the CPack
          module. Defaults to CPackConfig.cmake.

       

          CPACK_PACKAGE_EXECUTABLES - Lists each of the executables along
          with a text label, to be used to create Start Menu shortcuts on
          Windows. For example, setting this to the list ccmake;CMake will
          create a shortcut named "CMake" that will execute the installed
          executable ccmake.

       

          CPACK_STRIP_FILES - List of files to be stripped. Starting with
          CMake 2.6.0 CPACK_STRIP_FILES will be a boolean variable which
          enables stripping of all files (a list of files evaluates to TRUE
          in CMake, so this change is compatible).

       

       The following CPack variables are specific to source packages, and
       will not affect binary packages:

          CPACK_SOURCE_PACKAGE_FILE_NAME - The name of the source package,
          e.g., cmake-2.6.1

       

          CPACK_SOURCE_STRIP_FILES - List of files in the source tree that
          will be stripped. Starting with CMake 2.6.0
          CPACK_SOURCE_STRIP_FILES will be a boolean variable which enables
          stripping of all files (a list of files evaluates to TRUE in CMake,
          so this change is compatible).

       

          CPACK_SOURCE_GENERATOR - List of generators used for the source
          packages. As with CPACK_GENERATOR, if this is not specified then
          CPack will create a set of options (e.g., CPACK_SOURCE_ZIP)
          allowing users to select which packages will be generated.

       

          CPACK_SOURCE_OUTPUT_CONFIG_FILE - The name of the CPack
          configuration file for source installers that will be generated by
          the CPack module. Defaults to CPackSourceConfig.cmake.

       

          CPACK_SOURCE_IGNORE_FILES - Pattern of files in the source tree
          that won't be packaged when building a source package. This is a
          list of patterns, e.g., /CVS/;/\\.svn/;\\.swp$;\\.#;/#;.*~;cscope.*

       

       The following variables are specific to the graphical installers built
       on Windows using the Nullsoft Installation System.

          CPACK_PACKAGE_INSTALL_REGISTRY_KEY - Registry key used when
          installing this project.

       

          CPACK_NSIS_MUI_ICON - The icon file (.ico) for the generated
          install program.

       

          CPACK_NSIS_MUI_UNIICON - The icon file (.ico) for the generated
          uninstall program.

       

          CPACK_PACKAGE_ICON - A branding image that will be displayed inside
          the installer.

       

          CPACK_NSIS_EXTRA_INSTALL_COMMANDS - Extra NSIS commands that will
          be added to the install Section.

       

          CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS - Extra NSIS commands that will
          be added to the uninstall Section.

       

          CPACK_NSIS_COMPRESSOR - The arguments that will be passed to the
          NSIS SetCompressor command.

       

          CPACK_NSIS_MODIFY_PATH - If this is set to "ON", then an extra page
          will appear in the installer that will allow the user to choose
          whether the program directory should be added to the system PATH
          variable.

       

          CPACK_NSIS_DISPLAY_NAME - The display name string that appears in
          the Windows Add/Remove Program control panel

       

          CPACK_NSIS_PACKAGE_NAME - The title displayed at the top of the
          installer.

       

          CPACK_NSIS_INSTALLED_ICON_NAME - A path to the executable that
          contains the installer icon.

       

          CPACK_NSIS_HELP_LINK - URL to a web site providing assistance in
          installing your application.

       

          CPACK_NSIS_URL_INFO_ABOUT - URL to a web site providing more
          information about your application.

       

          CPACK_NSIS_CONTACT - Contact information for questions and comments
          about the installation process.

       

          CPACK_NSIS_CREATE_ICONS_EXTRA - Additional NSIS commands for
          creating start menu shortcuts.

       

          CPACK_NSIS_DELETE_ICONS_EXTRA -Additional NSIS commands to
          uninstall start menu shortcuts.

       

       The following variable is specific to installers build on Mac OS X
       using PackageMaker:

          CPACK_OSX_PACKAGE_VERSION - The version of Mac OS X that the
          resulting PackageMaker archive should be compatible
          with. Different versions of Mac OS X support different
          features. For example, CPack can only build component-based
          installers for Mac OS X 10.4 or newer, and can only build
          installers that download component son-the-fly for Mac OS X 10.5
          or newer. If left blank, this value will be set to the minimum
          version of Mac OS X that supports the requested features. Set this
          variable to some value (e.g., 10.4) only if you want to guarantee
          that your installer will work on that version of Mac OS X, and
          don't mind missing extra features available in the installer
          shipping with later versions of Mac OS X.

       

       The following variables are for advanced uses of CPack:

          CPACK_CMAKE_GENERATOR - What CMake generator should be used if the
          project is CMake project. Defaults to the value of CMAKE_GENERATOR;
          few users will want to change this setting.

       

          CPACK_INSTALL_CMAKE_PROJECTS - List of four values that specify
          what project to install. The four values are: Build directory,
          Project Name, Project Component, Directory. If omitted, CPack will
          build an installer that installers everything.

       

          CPACK_SYSTEM_NAME - System name, defaults to the value of
          ${CMAKE_SYSTEM_NAME}.

       

          CPACK_PACKAGE_VERSION - Package full version, used internally. By
          default, this is built from CPACK_PACKAGE_VERSION_MAJOR,
          CPACK_PACKAGE_VERSION_MINOR, and CPACK_PACKAGE_VERSION_PATCH.

       

          CPACK_TOPLEVEL_TAG - Directory for the installed files.

       

          CPACK_INSTALL_COMMANDS - Extra commands to install components.

       

          CPACK_INSTALL_DIRECTORIES - Extra directories to install.

       

       Component-specific installation allows users to select specific sets
       of components to install during the install process.  Installation
       components are identified by the COMPONENT argument of CMake's INSTALL
       commands, and should be further described by the following CPack
       commands:

          cpack_add_component - Describes a CPack installation component
          named by the COMPONENT argument to a CMake INSTALL command.

       

            cpack_add_component(compname
                                [DISPLAY_NAME name]
                                [DESCRIPTION description]
                                [HIDDEN | REQUIRED | DISABLED ]
                                [GROUP group]
                                [DEPENDS comp1 comp2 ... ]
                                [INSTALL_TYPES type1 type2 ... ]
                                [DOWNLOADED]
                                [ARCHIVE_FILE filename])

       

          The cmake_add_component command describes an installation
          component, which the user can opt to install or remove as part of
          the graphical installation process. compname is the name of the
          component, as provided to the COMPONENT argument of one or more
          CMake INSTALL commands.

       

          DISPLAY_NAME is the displayed name of the component, used in
          graphical installers to display the component name. This value can
          be any string.

       

          DESCRIPTION is an extended description of the component, used in
          graphical installers to give the user additional information about
          the component. Descriptions can span multiple lines using "\n" as
          the line separator. Typically, these descriptions should be no
          more than a few lines long.

       

          HIDDEN indicates that this component will be hidden in the
          graphical installer, so that the user cannot directly change
          whether it is installed or not.

       

          REQUIRED indicates that this component is required, and therefore
          will always be installed. It will be visible in the graphical
          installer, but it cannot be unselected. (Typically, required
          components are shown greyed out).

       

          DISABLED indicates that this component should be disabled
          (unselected) by default. The user is free to select this component
          for installation, unless it is also HIDDEN.

       

          DEPENDS lists the components on which this component depends. If
          this component is selected, then each of the components listed
          must also be selected. The dependency information is encoded
          within the installer itself, so that users cannot install
          inconsitent sets of components.

       

          GROUP names the component group of which this component is a
          part. If not provided, the component will be a standalone
          component, not part of any component group. Component groups are
          described with the cpack_add_component_group command, detailed
          below.

       

          INSTALL_TYPES lists the installation types of which this component
          is a part. When one of these installations types is selected, this
          component will automatically be selected. Installation types are
          described with the cpack_add_install_type command, detailed below.

       

          DOWNLOADED indicates that this component should be downloaded
          on-the-fly by the installer, rather than packaged in with the
          installer itself. For more information, see the cpack_configure_downloads
          command.

       

          ARCHIVE_FILE provides a name for the archive file created by CPack
          to be used for downloaded components. If not supplied, CPack will
          create a file with some name based on CPACK_PACKAGE_FILE_NAME and
          the name of the component. See cpack_configure_downloads for more
          information.

       

          cpack_add_component_group - Describes a group of related CPack
          installation components.

       

            cpack_add_component_group(groupname
                                     [DISPLAY_NAME name]
                                     [DESCRIPTION description]
                                     [PARENT_GROUP parent]
                                     [EXPANDED]
                                     [BOLD_TITLE])

       

          The cpack_add_component_group describes a group of installation
          components, which will be placed together within the listing of
          options. Typically, component groups allow the user to
          select/deselect all of the components within a single group via a
          single group-level option. Use component groups to reduce the
          complexity of installers with many options. groupname is an
          arbitrary name used to identify the group in the GROUP argument of
          the cpack_add_component command, which is used to place a
          component in a group. The name of the group must not conflict with
          the name of any component.

       

          DISPLAY_NAME is the displayed name of the component group, used in
          graphical installers to display the component group name. This
          value can be any string.

       

          DESCRIPTION is an extended description of the component group,
          used in graphical installers to give the user additional
          information about the components within that group. Descriptions
          can span multiple lines using "\n" as the line
          separator. Typically, these descriptions should be no more than a
          few lines long.

       

          PARENT_GROUP, if supplied, names the parent group of this group. 
          Parent groups are used to establish a hierarchy of groups, 
          providing an arbitrary hierarchy of groups.

       

          EXPANDED indicates that, by default, the group should show up as
          "expanded", so that the user immediately sees all of the
          components within the group. Otherwise, the group will initially
          show up as a single entry.

       

          BOLD_TITLE indicates that the group title should appear in bold,
          to call the user's attention to the group.

       

          cpack_add_install_type - Add a new installation type containing a
          set of predefined component selections to the graphical installer.
                             
            cpack_add_install_type(typename
                                   [DISPLAY_NAME name])   

       

          The cpack_add_install_type command identifies a set of preselected
          components that represents a common use case for an
          application. For example, a "Developer" install type might include
          an application along with its header and library files, while an
          "End user" install type might just include the application's
          executable. Each component identifies itself with one or more
          install types via the INSTALL_TYPES argument to
          cpack_add_component.

       

          DISPLAY_NAME is the displayed name of the install type, which will
          typically show up in a drop-down box within a graphical
          installer. This value can be any string.

       

          cpack_configure_downloads - Configure CPack to download selected
          components on-the-fly as part of the installation process.

       

            cpack_configure_downloads(site
                                      [UPLOAD_DIRECTORY dirname]
                                      [ALL]
                                      [ADD_REMOVE|NO_ADD_REMOVE])

       

          The cpack_configure_downloads command configures installation-time
          downloads of selected components. For each downloadable component,
          CPack will create an archive containing the contents of that
          component, which should be uploaded to the given site. When the
          user selects that component for installation, the installer will
          download and extract the component in place. This feature is
          useful for creating small installers that only download the
          requested components, saving bandwidth. Additionally, the
          installers are small enough that they will be installed as part of
          the normal installation process, and the "Change" button in
          Windows Add/Remove Programs control panel will allow one to add or
          remove parts of the application after the original
          installation. On Windows, the downloaded-components functionality
          requires the ZipDLL plug-in for NSIS, available at:

       

            http://nsis.sourceforge.net/ZipDLL_plug-in

       

          On Mac OS X, installers that download components on-the-fly can
          only be built and installed on system using Mac OS X 10.5 or
          later.

       

          The site argument is a URL where the archives for downloadable 
          components will reside, e.g., http://www.cmake.org/files/2.6.1/installer/
          All of the archives produced by CPack should be uploaded to that location.

       

          UPLOAD_DIRECTORY is the local directory where CPack will create the 
          various archives for each of the components. The contents of this
          directory should be uploaded to a location accessible by the URL given
          in the site argument. If omitted, CPack will use the directory 
          CPackUploads inside the CMake binary directory to store the generated
          archives.

       

          The ALL flag indicates that all components be downloaded. Otherwise, only 
          those components explicitly marked as DOWNLOADED or that have a specified 
          ARCHIVE_FILE will be downloaded. Additionally, the ALL option implies
          ADD_REMOVE (unless NO_ADD_REMOVE is specified).

       

          ADD_REMOVE indicates that CPack should install a copy of the installer
          that can be called from Windows' Add/Remove Programs dialog (via the 
          "Modify" button) to change the set of installed components. NO_ADD_REMOVE
          turns off this behavior. This option is ignored on Mac OS X.


  CPackDeb
       The builtin (binary) CPack Deb generator (Unix only)

       CPackDeb may be used to create Deb package using CPack.  CPackDeb is a
       CPack generator thus it uses the CPACK_XXX variables used by CPack :
       http://www.cmake.org/Wiki/CMake:CPackConfiguration

       However CPackRPM has specific features which are controlled by the
       specifics CPACK_RPM_XXX variables.You'll find a detailed usage on the
       wiki:

         http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#DEB_.28UNIX_only.29

       However as a handy reminder here comes the list of specific variables:

         CPACK_DEBIAN_PACKAGE_NAME
            Mandatory : YES
            Default   : CPACK_PACKAGE_NAME (lower case)
            The debian package summary

       CPACK_DEBIAN_PACKAGE_VERSION

            Mandatory : YES
            Default   : CPACK_PACKAGE_VERSION
            The debian package version

       CPACK_DEBIAN_PACKAGE_ARCHITECTURE)

            Mandatory : YES
            Default   : Output of dpkg --print-architecture or i386
            The debian package architecture

       CPACK_DEBIAN_PACKAGE_DEPENDS

            Mandatory : NO
            Default   : -
            May be used to set deb dependencies. 

       CPACK_DEBIAN_PACKAGE_MAINTAINER

            Mandatory : YES
            Default   : CPACK_PACKAGE_CONTACT
            The debian package maintainer

       CPACK_DEBIAN_PACKAGE_DESCRIPTION

            Mandatory : YES
            Default   : CPACK_PACKAGE_DESCRIPTION_SUMMARY
            The debian package description

       CPACK_DEBIAN_PACKAGE_SECTION

            Mandatory : YES
            Default   : 'devel'
            The debian package section

       CPACK_DEBIAN_PACKAGE_PRIORITY

            Mandatory : YES
            Default   : 'optional'
            The debian package priority


  CPackRPM
       The builtin (binary) CPack RPM generator (Unix only)

       CPackRPM may be used to create RPM package using CPack.  CPackRPM is a
       CPack generator thus it uses the CPACK_XXX variables used by CPack :
       http://www.cmake.org/Wiki/CMake:CPackConfiguration

       However CPackRPM has specific features which are controlled by the
       specifics CPACK_RPM_XXX variables.You'll find a detailed usage on the
       wiki:

         http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#RPM_.28Unix_Only.29

       However as a handy reminder here comes the list of specific variables:

         CPACK_RPM_PACKAGE_SUMMARY 
            Mandatory : YES
            Default   : CPACK_PACKAGE_DESCRIPTION
            The RPM package summary
         CPACK_RPM_PACKAGE_NAME
            Mandatory : YES
            Default   : CPACK_PACKAGE_NAME
            The RPM package name
         CPACK_RPM_PACKAGE_VERSION
            Mandatory : YES
            Default   : CPACK_PACKAGE_VERSION
            The RPM package version
         CPACK_RPM_PACKAGE_ARCHITECTURE
            Mandatory : NO
            Default   : -
            The RPM package architecture. This may be set to "noarch" if you 
            know you are building a noarch package.
         CPACK_RPM_PACKAGE_RELEASE
            Mandatory : YES
            Default   : 1
            The RPM package release. This is the numbering of the RPM package 
            itself, i.e. the version of the packaging and not the version of the 
            content (see CPACK_RPM_PACKAGE_VERSION). One may change the default 
            value if the previous packaging was buggy and/or you want to put here
            a fancy Linux distro specific numbering.
         CPACK_RPM_PACKAGE_LICENSE
            Mandatory : YES
            Default   : "unknown"
            The RPM package license policy.
         CPACK_RPM_PACKAGE_GROUP
            Mandatory : YES
            Default   : "unknown"
            The RPM package group.
         CPACK_RPM_PACKAGE_VENDOR 
            Mandatory : YES
            Default   : CPACK_PACKAGE_VENDOR if set or"unknown"
            The RPM package group.
         CPACK_RPM_PACKAGE_DESCRIPTION
            Mandatory : YES
            Default   : CPACK_PACKAGE_DESCRIPTION_FILE if set or "no package description available"
         CPACK_RPM_PACKAGE_REQUIRES
            Mandatory : NO
            Default   : -
            May be used to set RPM dependencies. 
         CPACK_RPM_SPEC_INSTALL_POST
            Mandatory : NO
            Default   : -
            May be used to set an RPM post-install command inside the spec file. 
            For example setting it to "/bin/true" may be used to prevent 
            rpmbuild to strip binaries.
         CPACK_RPM_SPEC_MORE_DEFINE
            Mandatory : NO
            Default   : -
            May be used to add any %define lines to the generated spec file.
         CPACK_RPM_PACKAGE_DEBUG
            Mandatory : NO
            Default   : -
            May be set when invoking cpack in order to trace debug informations 
            during CPack RPM run. For example you may launch CPack like this 
            cpack -D CPACK_RPM_PACKAGE_DEBUG=1 -G RPM


  CTest
       Configure a project for testing with CTest/CDash

       This file configures a project to use the CTest/CDash/Dart
       testing/dashboard process.  This module should be included in the
       CMakeLists.txt file at the top of a project.  Typical usage:

         INCLUDE(CTest)
         IF(BUILD_TESTING)
           # ... testing related CMake code ...
         ENDIF(BUILD_TESTING)

       The BUILD_TESTING option is created by the CTest module to determine
       whether testing support should be enabled.  The default is ON.

  CTestScriptMode
        

       This file is read by ctest in script mode (-S)

  CheckCCompilerFlag
       Check whether the C compiler supports a given flag.

       CHECK_C_COMPILER_FLAG(<flag> <var>)

         <flag> - the compiler flag
         <var>  - variable to store the result

       This internally calls the check_c_source_compiles macro.  See help for
       CheckCSourceCompiles for a listing of variables that can modify the
       build.

  CheckCSourceCompiles
       Check if the given C source code compiles.

       CHECK_C_SOURCE_COMPILES(<code> <var> [FAIL_REGEX <fail-regex>])

         <code>       - source code to try to compile
         <var>        - variable to store whether the source code compiled
         <fail-regex> - fail if test output matches this regex

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckCSourceRuns
       Check if the given C source code compiles and runs.

       CHECK_C_SOURCE_RUNS(<code> <var>)

         <code>   - source code to try to compile
         <var>    - variable to store the result
                    (1 for success, empty for failure)

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckCXXCompilerFlag
       Check whether the CXX compiler supports a given flag.

       CHECK_CXX_COMPILER_FLAG(<flag> <var>)

         <flag> - the compiler flag
         <var>  - variable to store the result

       This internally calls the check_cxx_source_compiles macro.  See help
       for CheckCXXSourceCompiles for a listing of variables that can modify
       the build.

  CheckCXXSourceCompiles
       Check if the given C++ source code compiles.

       CHECK_CXX_SOURCE_COMPILES(<code> <var> [FAIL_REGEX <fail-regex>])

         <code>       - source code to try to compile
         <var>        - variable to store whether the source code compiled
         <fail-regex> - fail if test output matches this regex

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckCXXSourceRuns
       Check if the given C++ source code compiles and runs.

       CHECK_CXX_SOURCE_RUNS(<code> <var>)

         <code>   - source code to try to compile
         <var>    - variable to store the result
                    (1 for success, empty for failure)

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckFortranFunctionExists
       macro which checks if the Fortran function exists

       CHECK_FORTRAN_FUNCTION_EXISTS(FUNCTION VARIABLE)

         FUNCTION - the name of the Fortran function
         VARIABLE - variable to store the result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckFunctionExists
       macro which checks if the function exists

       CHECK_FUNCTION_EXISTS(FUNCTION VARIABLE)

         FUNCTION - the name of the function
         VARIABLE - variable to store the result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckIncludeFile
       macro which checks the include file exists.

       CHECK_INCLUDE_FILE(INCLUDE VARIABLE)

         INCLUDE  - name of include file
         VARIABLE - variable to return result
          

       an optional third argument is the CFlags to add to the compile line or
       you can use CMAKE_REQUIRED_FLAGS

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories

       


  CheckIncludeFileCXX
       Check if the include file exists.

         CHECK_INCLUDE_FILE_CXX(INCLUDE VARIABLE)

       

         INCLUDE  - name of include file
         VARIABLE - variable to return result
         

       An optional third argument is the CFlags to add to the compile line or
       you can use CMAKE_REQUIRED_FLAGS.

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories

       


  CheckIncludeFiles
       Check if the files can be included

       

       CHECK_INCLUDE_FILES(INCLUDE VARIABLE)

         INCLUDE  - list of files to include
         VARIABLE - variable to return result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories


  CheckLibraryExists
       Check if the function exists.

       CHECK_LIBRARY_EXISTS (LIBRARY FUNCTION LOCATION VARIABLE)

         LIBRARY  - the name of the library you are looking for
         FUNCTION - the name of the function
         LOCATION - location where the library should be found
         VARIABLE - variable to store the result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckStructHasMember
       Check if the given struct or class has the specified member variable

       CHECK_STRUCT_HAS_MEMBER (STRUCT MEMBER HEADER VARIABLE)

         STRUCT - the name of the struct or class you are interested in
         MEMBER - the member which existence you want to check
         HEADER - the header(s) where the prototype should be declared
         VARIABLE - variable to store the result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories

       

       Example: CHECK_STRUCT_HAS_MEMBER("struct timeval" tv_sec sys/select.h
       HAVE_TIMEVAL_TV_SEC)

  CheckSymbolExists
       Check if the symbol exists in include files

       CHECK_SYMBOL_EXISTS(SYMBOL FILES VARIABLE)

         SYMBOL   - symbol
         FILES    - include files to check
         VARIABLE - variable to return result

       

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckTypeSize
       Check sizeof a type

         CHECK_TYPE_SIZE(TYPE VARIABLE [BUILTIN_TYPES_ONLY])

       Check if the type exists and determine size of type.  if the type
       exists, the size will be stored to the variable.  This also calls
       check_include_file for sys/types.h stdint.h and stddef.h, setting
       HAVE_SYS_TYPES_H, HAVE_STDINT_H, and HAVE_STDDEF_H.  This is because
       many types are stored in these include files.

         VARIABLE - variable to store size if the type exists.
         HAVE_${VARIABLE} - does the variable exists or not
         BUILTIN_TYPES_ONLY - The third argument is optional and if 
                              it is set to the string BUILTIN_TYPES_ONLY
                              this macro will not check for any header files.

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_INCLUDES = list of include directories
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  CheckVariableExists
       Check if the variable exists.

         CHECK_VARIABLE_EXISTS(VAR VARIABLE)
         
         VAR      - the name of the variable
         VARIABLE - variable to store the result

       

       This macro is only for C variables.

       The following variables may be set before calling this macro to modify
       the way the check is run:

         CMAKE_REQUIRED_FLAGS = string of compile command line flags
         CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
         CMAKE_REQUIRED_LIBRARIES = list of libraries to link


  Dart
       Configure a project for testing with CTest or old Dart Tcl Client

       This file is the backwards-compatibility version of the CTest module.
       It supports using the old Dart 1 Tcl client for driving dashboard
       submissions as well as testing with CTest.  This module should be
       included in the CMakeLists.txt file at the top of a project.  Typical
       usage:

         INCLUDE(Dart)
         IF(BUILD_TESTING)
           # ... testing related CMake code ...
         ENDIF(BUILD_TESTING)

       The BUILD_TESTING option is created by the Dart module to determine
       whether testing support should be enabled.  The default is ON.

  Documentation
       DocumentationVTK.cmake

       This file provides support for the VTK documentation framework.  It
       relies on several tools (Doxygen, Perl, etc).

  ExternalProject
       Create custom targets to build projects in external trees

       The 'ExternalProject_Add' function creates a custom target to drive
       download, update/patch, configure, build, install and test steps of an
       external project:

         ExternalProject_Add(<name>    # Name for custom target
           [DEPENDS projects...]       # Targets on which the project depends
           [PREFIX dir]                # Root dir for entire project
           [LIST_SEPARATOR sep]        # Sep to be replaced by ; in cmd lines
           [TMP_DIR dir]               # Directory to store temporary files
           [STAMP_DIR dir]             # Directory to store step timestamps
          #--Download step--------------
           [DOWNLOAD_DIR dir]          # Directory to store downloaded files
           [DOWNLOAD_COMMAND cmd...]   # Command to download source tree
           [CVS_REPOSITORY cvsroot]    # CVSROOT of CVS repository
           [CVS_MODULE mod]            # Module to checkout from CVS repo
           [CVS_TAG tag]               # Tag to checkout from CVS repo
           [SVN_REPOSITORY url]        # URL of Subversion repo
           [SVN_REVISION rev]          # Revision to checkout from Subversion repo
           [URL /.../src.tgz]          # Full path or URL of source
          #--Update/Patch step----------
           [UPDATE_COMMAND cmd...]     # Source work-tree update command
           [PATCH_COMMAND cmd...]      # Command to patch downloaded source
          #--Configure step-------------
           [SOURCE_DIR dir]            # Source dir to be used for build
           [CONFIGURE_COMMAND cmd...]  # Build tree configuration command
           [CMAKE_COMMAND /.../cmake]  # Specify alternative cmake executable
           [CMAKE_GENERATOR gen]       # Specify generator for native build
           [CMAKE_ARGS args...]        # Arguments to CMake command line
          #--Build step-----------------
           [BINARY_DIR dir]            # Specify build dir location
           [BUILD_COMMAND cmd...]      # Command to drive the native build
           [BUILD_IN_SOURCE 1]         # Use source dir for build dir
          #--Install step---------------
           [INSTALL_DIR dir]           # Installation prefix
           [INSTALL_COMMAND cmd...]    # Command to drive install after build
          #--Test step---------------
           [TEST_BEFORE_INSTALL 1]     # Add test step executed before install step
           [TEST_AFTER_INSTALL 1]      # Add test step executed after install step
           [TEST_COMMAND cmd...]       # Command to drive test
           )

       The *_DIR options specify directories for the project, with default
       directories computed as follows.  If the PREFIX option is given to
       ExternalProject_Add() or the EP_PREFIX directory property is set, then
       an external project is built and installed under the specified prefix:

          TMP_DIR      = <prefix>/tmp
          STAMP_DIR    = <prefix>/src/<name>-stamp
          DOWNLOAD_DIR = <prefix>/src
          SOURCE_DIR   = <prefix>/src/<name>
          BINARY_DIR   = <prefix>/src/<name>-build
          INSTALL_DIR  = <prefix>

       Otherwise, if the EP_BASE directory property is set then components of
       an external project are stored under the specified base:

          TMP_DIR      = <base>/tmp/<name>
          STAMP_DIR    = <base>/Stamp/<name>
          DOWNLOAD_DIR = <base>/Download/<name>
          SOURCE_DIR   = <base>/Source/<name>
          BINARY_DIR   = <base>/Build/<name>
          INSTALL_DIR  = <base>/Install/<name>

       If no PREFIX, EP_PREFIX, or EP_BASE is specified then the default is
       to set PREFIX to "<name>-prefix".  Relative paths are interpreted with
       respect to the build directory corresponding to the source directory
       in which ExternalProject_Add is invoked.

       If SOURCE_DIR is explicitly set to an existing directory the project
       will be built from it.  Otherwise a download step must be specified
       using one of the DOWNLOAD_COMMAND, CVS_*, SVN_*, or URL options.  The
       URL option may refer locally to a directory or source tarball, or
       refer to a remote tarball (e.g.  http://.../src.tgz).

       The 'ExternalProject_Add_Step' function adds a custom step to an
       external project:

         ExternalProject_Add_Step(<name> <step> # Names of project and custom step
           [COMMAND cmd...]        # Command line invoked by this step
           [COMMENT "text..."]     # Text printed when step executes
           [DEPENDEES steps...]    # Steps on which this step depends
           [DEPENDERS steps...]    # Steps that depend on this step
           [DEPENDS files...]      # Files on which this step depends
           [ALWAYS 1]              # No stamp file, step always runs
           [WORKING_DIRECTORY dir] # Working directory for command
           )

       The command line, comment, and working directory of every standard and
       custom step is processed to replace tokens <SOURCE_DIR>, <BINARY_DIR>,
       <INSTALL_DIR>, and <TMP_DIR> with corresponding property values.

       The 'ExternalProject_Get_Property' function retrieves external project
       target properties:

         ExternalProject_Get_Property(<name> [prop1 [prop2 [...]]])

       It stores property values in variables of the same name.  Property
       names correspond to the keyword argument names of
       'ExternalProject_Add'.

  FeatureSummary
       Macros for generating a summary of enabled/disabled features

       

       PRINT_ENABLED_FEATURES()

          Print a summary of all enabled features. By default all successfull
          FIND_PACKAGE() calls will appear here, except the ones which used the
          QUIET keyword. Additional features can be added by appending an entry
          to the global ENABLED_FEATURES property. If SET_FEATURE_INFO() is
          used for that feature, the output will be much more informative.

       

       PRINT_DISABLED_FEATURES()

          Same as PRINT_ENABLED_FEATURES(), but for disabled features. It can
          be extended the same way by adding to the global property 
          DISABLED_FEATURES.

       

       SET_FEATURE_INFO(NAME DESCRIPTION [URL [COMMENT] ] )

           Use this macro to set up information about the named feature, which will
           then be displayed by PRINT_ENABLED/DISABLED_FEATURES().
           Example: SET_FEATURE_INFO(LibXml2 "XML processing library." 
           "http://xmlsoft.org/")

       


  FindALSA
       Find alsa

       Find the alsa libraries (asound)

         This module defines the following variables:
            ALSA_FOUND       - True if ALSA_INCLUDE_DIR & ALSA_LIBRARY are found
            ALSA_LIBRARIES   - Set when ALSA_LIBRARY is found
            ALSA_INCLUDE_DIRS - Set when ALSA_INCLUDE_DIR is found

       

            ALSA_INCLUDE_DIR - where to find asoundlib.h, etc.
            ALSA_LIBRARY     - the asound library

       


  FindASPELL
       Try to find ASPELL

       Once done this will define

         ASPELL_FOUND - system has ASPELL
         ASPELL_INCLUDE_DIR - the ASPELL include directory
         ASPELL_LIBRARIES - The libraries needed to use ASPELL
         ASPELL_DEFINITIONS - Compiler switches required for using ASPELL


  FindAVIFile
       Locate AVIFILE library and include paths

       AVIFILE (http://avifile.sourceforge.net/)is a set of libraries for
       i386 machines to use various AVI codecs.  Support is limited beyond
       Linux.  Windows provides native AVI support, and so doesn't need this
       library.  This module defines

         AVIFILE_INCLUDE_DIR, where to find avifile.h , etc.
         AVIFILE_LIBRARIES, the libraries to link against
         AVIFILE_DEFINITIONS, definitions to use when compiling
         AVIFILE_FOUND, If false, don't try to use AVIFILE


  FindBISON
       Find bison executable and provides macros to generate custom build
       rules

       The module defines the following variables:

         BISON_EXECUTABLE - path to the bison program
         BISON_VERSION - version of bison
         BISON_FOUND - true if the program was found

       

       If bison is found, the module defines the macros:

         BISON_TARGET(<Name> <YaccInput> <CodeOutput> [VERBOSE <file>]
                     [COMPILE_FLAGS <string>])

       which will create a custom rule to generate a parser.  <YaccInput> is
       the path to a yacc file.  <CodeOutput> is the name of the source file
       generated by bison.  A header file is also be generated, and contains
       the token list.  If COMPILE_FLAGS option is specified, the next
       parameter is added in the bison command line.  if VERBOSE option is
       specified, <file> is created and contains verbose descriptions of the
       grammar and parser.  The macro defines a set of variables:

         BISON_${Name}_DEFINED - true is the macro ran successfully
         BISON_${Name}_INPUT - The input source file, an alias for <YaccInput>
         BISON_${Name}_OUTPUT_SOURCE - The source file generated by bison
         BISON_${Name}_OUTPUT_HEADER - The header file generated by bison
         BISON_${Name}_OUTPUTS - The sources files generated by bison
         BISON_${Name}_COMPILE_FLAGS - Options used in the bison command line

       

         ====================================================================
         Example:

       

          find_package(BISON)
          BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
          add_executable(Foo main.cpp ${BISON_MyParser_OUTPUTS})
         ====================================================================


  FindBLAS
       Find BLAS library

       This module finds an installed fortran library that implements the
       BLAS linear-algebra interface (see http://www.netlib.org/blas/).  The
       list of libraries searched for is taken from the autoconf macro file,
       acx_blas.m4 (distributed at
       http://ac-archive.sourceforge.net/ac-archive/acx_blas.html).

       This module sets the following variables:

         BLAS_FOUND - set to true if a library implementing the BLAS interface
           is found
         BLAS_LINKER_FLAGS - uncached list of required linker flags (excluding -l
           and -L).
         BLAS_LIBRARIES - uncached list of libraries (using full path name) to
           link against to use BLAS
         BLAS95_LIBRARIES - uncached list of libraries (using full path name)
           to link against to use BLAS95 interface
         BLAS95_FOUND - set to true if a library implementing the BLAS f95 interface
           is found
         BLA_STATIC  if set on this determines what kind of linkage we do (static)
         BLA_VENDOR  if set checks only the specified vendor, if not set checks
            all the possibilities
         BLA_F95     if set on tries to find the f95 interfaces for BLAS/LAPACK

       ######### ## List of vendors (BLA_VENDOR) valid in this module #
       ATLAS, PhiPACK,CXML,DXML,SunPerf,SCSL,SGIMATH,IBMESSL,Intel10_32
       (intel mkl v10 32 bit),Intel10_64lp (intel mkl v10 64 bit,lp thread
       model, lp64 model), # Intel( older versions of mkl 32 and 64 bit),
       ACML,Apple, NAS, Generic C/CXX should be enabled to use Intel mkl

  FindBZip2
       Try to find BZip2

       Once done this will define

         BZIP2_FOUND - system has BZip2
         BZIP2_INCLUDE_DIR - the BZip2 include directory
         BZIP2_LIBRARIES - Link these to use BZip2
         BZIP2_DEFINITIONS - Compiler switches required for using BZip2
         BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_


  FindBoost
       Try to find Boost include dirs and libraries

       Usage of this module as follows:

       NOTE: Take note of the Boost_ADDITIONAL_VERSIONS variable below.  Due
       to Boost naming conventions and limitations in CMake this find module
       is NOT future safe with respect to Boost version numbers, and may
       break.

       == Using Header-Only libraries from within Boost: ==

          find_package( Boost 1.36.0 )
          if(Boost_FOUND)
             include_directories(${Boost_INCLUDE_DIRS})
             add_executable(foo foo.cc)
          endif()

       

       

       == Using actual libraries from within Boost: ==

          set(Boost_USE_STATIC_LIBS   ON)
          set(Boost_USE_MULTITHREADED ON)
          find_package( Boost 1.36.0 COMPONENTS date_time filesystem system ... )

       

          if(Boost_FOUND)
             include_directories(${Boost_INCLUDE_DIRS})
             add_executable(foo foo.cc)
             target_link_libraries(foo ${Boost_LIBRARIES})
          endif()

       

       

       The components list needs to contain actual names of boost libraries
       only, such as "date_time" for "libboost_date_time".  If you're using
       parts of Boost that contain header files only (e.g.  foreach) you do
       not need to specify COMPONENTS.

       You should provide a minimum version number that should be used.  If
       you provide this version number and specify the REQUIRED attribute,
       this module will fail if it can't find the specified or a later
       version.  If you specify a version number this is automatically put
       into the considered list of version numbers and thus doesn't need to
       be specified in the Boost_ADDITIONAL_VERSIONS variable (see below).

       NOTE for Visual Studio Users:

            Automatic linking is used on MSVC & Borland compilers by default when
            #including things in Boost.  It's important to note that setting
            Boost_USE_STATIC_LIBS to OFF is NOT enough to get you dynamic linking,
            should you need this feature.  Automatic linking typically uses static
            libraries with a few exceptions (Boost.Python is one).

       

            Please see the section below near Boost_LIB_DIAGNOSTIC_DEFINITIONS for
            more details.  Adding a TARGET_LINK_LIBRARIES() as shown in the example
            above appears to cause VS to link dynamically if Boost_USE_STATIC_LIBS
            gets set to OFF.  It is suggested you avoid automatic linking since it
            will make your application less portable.

       

       =========== The mess that is Boost_ADDITIONAL_VERSIONS (sorry?)
       ============

       OK, so the Boost_ADDITIONAL_VERSIONS variable can be used to specify a
       list of boost version numbers that should be taken into account when
       searching for Boost.  Unfortunately boost puts the version number into
       the actual filename for the libraries, so this variable will certainly
       be needed in the future when new Boost versions are released.

       Currently this module searches for the following version numbers:
       1.33, 1.33.0, 1.33.1, 1.34, 1.34.0, 1.34.1, 1.35, 1.35.0, 1.35.1,
       1.36, 1.36.0, 1.36.1, 1.37, 1.37.0, 1.38, 1.38.0, 1.39, 1.39.0, 1.40,
       1.40.0

       NOTE: If you add a new major 1.x version in Boost_ADDITIONAL_VERSIONS
       you should add both 1.x and 1.x.0 as shown above.  Official Boost
       include directories omit the 3rd version number from include paths if
       it is 0 although not all binary Boost releases do so.

       SET(Boost_ADDITIONAL_VERSIONS "1.78" "1.78.0" "1.79" "1.79.0")

       ===================================== =============
       ========================

       Variables used by this module, they can change the default behaviour
       and need to be set before calling find_package:

          Boost_USE_MULTITHREADED      Can be set to OFF to use the non-multithreaded
                                       boost libraries.  If not specified, defaults
                                       to ON.

       

          Boost_USE_STATIC_LIBS        Can be set to ON to force the use of the static
                                       boost libraries. Defaults to OFF.

       

       Other Variables used by this module which you may want to set.

          Boost_ADDITIONAL_VERSIONS    A list of version numbers to use for searching
                                       the boost include directory.  Please see
                                       the documentation above regarding this
                                       annoying, but necessary variable :(

       

          Boost_DEBUG                  Set this to TRUE to enable debugging output
                                       of FindBoost.cmake if you are having problems.
                                       Please enable this before filing any bug
                                       reports.

       

          Boost_DETAILED_FAILURE_MSG   FindBoost doesn't output detailed information
                                       about why it failed or how to fix the problem
                                       unless this is set to TRUE or the REQUIRED
                                       keyword is specified in find_package().
                                         [Since CMake 2.8.0]

       

          Boost_COMPILER               Set this to the compiler suffix used by Boost
                                       (e.g. "-gcc43") if FindBoost has problems finding
                                       the proper Boost installation

       

       These last three variables are available also as environment
       variables:

          BOOST_ROOT or BOOSTROOT      The preferred installation prefix for searching for
                                       Boost.  Set this if the module has problems finding
                                       the proper Boost installation.

       

          BOOST_INCLUDEDIR             Set this to the include directory of Boost, if the
                                       module has problems finding the proper Boost installation

       

          BOOST_LIBRARYDIR             Set this to the lib directory of Boost, if the
                                       module has problems finding the proper Boost installation

       

       Variables defined by this module:

          Boost_FOUND                         System has Boost, this means the include dir was
                                              found, as well as all the libraries specified in
                                              the COMPONENTS list.

       

          Boost_INCLUDE_DIRS                  Boost include directories: not cached

       

          Boost_INCLUDE_DIR                   This is almost the same as above, but this one is
                                              cached and may be modified by advanced users

       

          Boost_LIBRARIES                     Link to these to use the Boost libraries that you
                                              specified: not cached

       

          Boost_LIBRARY_DIRS                  The path to where the Boost library files are.

       

          Boost_VERSION                       The version number of the boost libraries that
                                              have been found, same as in version.hpp from Boost

       

          Boost_LIB_VERSION                   The version number in filename form as
                                              it's appended to the library filenames

       

          Boost_MAJOR_VERSION                 major version number of boost
          Boost_MINOR_VERSION                 minor version number of boost
          Boost_SUBMINOR_VERSION              subminor version number of boost

       

          Boost_LIB_DIAGNOSTIC_DEFINITIONS    [WIN32 Only] You can call
                                              add_definitions(${Boost_LIB_DIAGNOSTIC_DEFINITIONS})
                                              to have diagnostic information about Boost's
                                              automatic linking outputted during compilation time.

       

       For each component you specify in find_package(), the following
       (UPPER-CASE) variables are set.  You can use these variables if you
       would like to pick and choose components for your targets instead of
       just using Boost_LIBRARIES.

          Boost_${COMPONENT}_FOUND            True IF the Boost library "component" was found.

       

          Boost_${COMPONENT}_LIBRARY          Contains the libraries for the specified Boost
                                              "component" (includes debug and optimized keywords
                                              when needed).


  FindBullet
       Try to find the Bullet physics engine

       

         This module defines the following variables

       

         BULLET_FOUND - Was bullet found
         BULLET_INCLUDE_DIRS - the Bullet include directories
         BULLET_LIBRARIES - Link to this, by default it includes
                            all bullet components (Dynamics,
                            Collision, LinearMath, & SoftBody)

       

         This module accepts the following variables

       

         BULLET_ROOT - Can be set to bullet install path or Windows build path

       


  FindCABLE
       Find CABLE

       This module finds if CABLE is installed and determines where the
       include files and libraries are.  This code sets the following
       variables:

         CABLE             the path to the cable executable
         CABLE_TCL_LIBRARY the path to the Tcl wrapper library
         CABLE_INCLUDE_DIR the path to the include directory

       

       To build Tcl wrappers, you should add shared library and link it to
       ${CABLE_TCL_LIBRARY}.  You should also add ${CABLE_INCLUDE_DIR} as an
       include directory.

  FindCUDA
       Tools for building CUDA C files: libraries and build dependencies.

       This script locates the NVIDIA CUDA C tools.  It should work on linux,
       windows, and mac and should be reasonably up to date with CUDA C
       releases.

       This script makes use of the standard find_package arguments of
       <VERSION>, REQUIRED and QUIET.  CUDA_FOUND will report if an
       acceptable version of CUDA was found.

       The script will prompt the user to specify CUDA_TOOLKIT_ROOT_DIR if
       the prefix cannot be determined by the location of nvcc in the system
       path and REQUIRED is specified to find_package().  To use a different
       installed version of the toolkit set the environment variable
       CUDA_BIN_PATH before running cmake (e.g.
       CUDA_BIN_PATH=/usr/local/cuda1.0 instead of the default
       /usr/local/cuda) or set CUDA_TOOLKIT_ROOT_DIR after configuring.  If
       you change the value of CUDA_TOOLKIT_ROOT_DIR, various components that
       depend on the path will be relocated.

       It might be necessary to set CUDA_TOOLKIT_ROOT_DIR manually on certain
       platforms, or to use a cuda runtime not installed in the default
       location.  In newer versions of the toolkit the cuda library is
       included with the graphics driver- be sure that the driver version
       matches what is needed by the cuda runtime version.

       The following variables affect the behavior of the macros in the
       script (in alphebetical order).  Note that any of these flags can be
       changed multiple times in the same directory before calling
       CUDA_ADD_EXECUTABLE, CUDA_ADD_LIBRARY, CUDA_COMPILE, CUDA_COMPILE_PTX
       or CUDA_WRAP_SRCS.

         CUDA_64_BIT_DEVICE_CODE (Default matches host bit size)
         -- Set to ON to compile for 64 bit device code, OFF for 32 bit device code.
            Note that making this different from the host code when generating object
            or C files from CUDA code just won't work, because size_t gets defined by
            nvcc in the generated source.  If you compile to PTX and then load the
            file yourself, you can mix bit sizes between device and host.

       

         CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE (Default ON)
         -- Set to ON if you want the custom build rule to be attached to the source
            file in Visual Studio.  Turn OFF if you add the same cuda file to multiple
            targets.

       

            This allows the user to build the target from the CUDA file; however, bad
            things can happen if the CUDA source file is added to multiple targets.
            When performing parallel builds it is possible for the custom build
            command to be run more than once and in parallel causing cryptic build
            errors.  VS runs the rules for every source file in the target, and a
            source can have only one rule no matter how many projects it is added to.
            When the rule is run from multiple targets race conditions can occur on
            the generated file.  Eventually everything will get built, but if the user
            is unaware of this behavior, there may be confusion.  It would be nice if
            this script could detect the reuse of source files across multiple targets
            and turn the option off for the user, but no good solution could be found.

       

         CUDA_BUILD_CUBIN (Default OFF)
         -- Set to ON to enable and extra compilation pass with the -cubin option in
            Device mode. The output is parsed and register, shared memory usage is
            printed during build.

       

         CUDA_BUILD_EMULATION (Default OFF for device mode)
         -- Set to ON for Emulation mode. -D_DEVICEEMU is defined for CUDA C files
            when CUDA_BUILD_EMULATION is TRUE.

       

         CUDA_GENERATED_OUTPUT_DIR (Default CMAKE_CURRENT_BINARY_DIR)
         -- Set to the path you wish to have the generated files placed.  If it is
            blank output files will be placed in CMAKE_CURRENT_BINARY_DIR.
            Intermediate files will always be placed in
            CMAKE_CURRENT_BINARY_DIR/CMakeFiles.

       

         CUDA_HOST_COMPILATION_CPP (Default ON)
         -- Set to OFF for C compilation of host code.

       

         CUDA_NVCC_FLAGS
         CUDA_NVCC_FLAGS_<CONFIG>
         -- Additional NVCC command line arguments.  NOTE: multiple arguments must be
            semi-colon delimited (e.g. --compiler-options;-Wall)

       

         CUDA_PROPAGATE_HOST_FLAGS (Default ON)
         -- Set to ON to propagate CMAKE_{C,CXX}_FLAGS and their configuration
            dependent counterparts (e.g. CMAKE_C_FLAGS_DEBUG) automatically to the
            host compiler through nvcc's -Xcompiler flag.  This helps make the
            generated host code match the rest of the system better.  Sometimes
            certain flags give nvcc problems, and this will help you turn the flag
            propagation off.  This does not affect the flags supplied directly to nvcc
            via CUDA_NVCC_FLAGS or through the OPTION flags specified through
            CUDA_ADD_LIBRARY, CUDA_ADD_EXECUTABLE, or CUDA_WRAP_SRCS.  Flags used for
            shared library compilation are not affected by this flag.

       

         CUDA_VERBOSE_BUILD (Default OFF)
         -- Set to ON to see all the commands used when building the CUDA file.  When
            using a Makefile generator the value defaults to VERBOSE (run make
            VERBOSE=1 to see output), although setting CUDA_VERBOSE_BUILD to ON will
            always print the output.

       

       The script creates the following macros (in alphebetical order):

         CUDA_ADD_CUFFT_TO_TARGET( cuda_target )
         -- Adds the cufft library to the target (can be any target).  Handles whether
            you are in emulation mode or not.

       

         CUDA_ADD_CUBLAS_TO_TARGET( cuda_target )
         -- Adds the cublas library to the target (can be any target).  Handles
            whether you are in emulation mode or not.

       

         CUDA_ADD_EXECUTABLE( cuda_target file0 file1 ...
                              [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [OPTIONS ...] )
         -- Creates an executable "cuda_target" which is made up of the files
            specified.  All of the non CUDA C files are compiled using the standard
            build rules specified by CMAKE and the cuda files are compiled to object
            files using nvcc and the host compiler.  In addition CUDA_INCLUDE_DIRS is
            added automatically to include_directories().  Standard CMake target calls
            can be used on the target after calling this macro
            (e.g. set_target_properties and target_link_libraries).

       

         CUDA_ADD_LIBRARY( cuda_target file0 file1 ...
                           [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [OPTIONS ...] )
         -- Same as CUDA_ADD_EXECUTABLE except that a library is created.

       

         CUDA_BUILD_CLEAN_TARGET()
         -- Creates a convience target that deletes all the dependency files
            generated.  You should make clean after running this target to ensure the
            dependency files get regenerated.

       

         CUDA_COMPILE( generated_files file0 file1 ... [STATIC | SHARED | MODULE]
                       [OPTIONS ...] )
         -- Returns a list of generated files from the input source files to be used
            with ADD_LIBRARY or ADD_EXECUTABLE.

       

         CUDA_COMPILE_PTX( generated_files file0 file1 ... [OPTIONS ...] )
         -- Returns a list of PTX files generated from the input source files.

       

         CUDA_INCLUDE_DIRECTORIES( path0 path1 ... )
         -- Sets the directories that should be passed to nvcc
            (e.g. nvcc -Ipath0 -Ipath1 ... ). These paths usually contain other .cu
            files.

       

         CUDA_WRAP_SRCS ( cuda_target format generated_files file0 file1 ...
                          [STATIC | SHARED | MODULE] [OPTIONS ...] )
         -- This is where all the magic happens.  CUDA_ADD_EXECUTABLE,
            CUDA_ADD_LIBRARY, CUDA_COMPILE, and CUDA_COMPILE_PTX all call this
            function under the hood.

       

            Given the list of files (file0 file1 ... fileN) this macro generates
            custom commands that generate either PTX or linkable objects (use "PTX" or
            "OBJ" for the format argument to switch).  Files that don't end with .cu
            or have the HEADER_FILE_ONLY property are ignored.

       

            The arguments passed in after OPTIONS are extra command line options to
            give to nvcc.  You can also specify per configuration options by
            specifying the name of the configuration followed by the options.  General
            options must preceed configuration specific options.  Not all
            configurations need to be specified, only the ones provided will be used.

       

               OPTIONS -DFLAG=2 "-DFLAG_OTHER=space in flag"
               DEBUG -g
               RELEASE --use_fast_math
               RELWITHDEBINFO --use_fast_math;-g
               MINSIZEREL --use_fast_math

       

            For certain configurations (namely VS generating object files with
            CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE set to ON), no generated file will
            be produced for the given cuda file.  This is because when you add the
            cuda file to Visual Studio it knows that this file produces an object file
            and will link in the resulting object file automatically.

       

            This script will also generate a separate cmake script that is used at
            build time to invoke nvcc.  This is for serveral reasons.

       

              1. nvcc can return negative numbers as return values which confuses
              Visual Studio into thinking that the command succeeded.  The script now
              checks the error codes and produces errors when there was a problem.

       

              2. nvcc has been known to not delete incomplete results when it
              encounters problems.  This confuses build systems into thinking the
              target was generated when in fact an unusable file exists.  The script
              now deletes the output files if there was an error.

       

              3. By putting all the options that affect the build into a file and then
              make the build rule dependent on the file, the output files will be
              regenerated when the options change.

       

            This script also looks at optional arguments STATIC, SHARED, or MODULE to
            determine when to target the object compilation for a shared library.
            BUILD_SHARED_LIBS is ignored in CUDA_WRAP_SRCS, but it is respected in
            CUDA_ADD_LIBRARY.  On some systems special flags are added for building
            objects intended for shared libraries.  A preprocessor macro,
            <target_name>_EXPORTS is defined when a shared library compilation is
            detected.

       

            Flags passed into add_definitions with -D or /D are passed along to nvcc.

       

       The script defines the following variables:

         CUDA_VERSION_MAJOR    -- The major version of cuda as reported by nvcc.
         CUDA_VERSION_MINOR    -- The minor version.
         CUDA_VERSION
         CUDA_VERSION_STRING   -- CUDA_VERSION_MAJOR.CUDA_VERSION_MINOR

       

         CUDA_TOOLKIT_ROOT_DIR -- Path to the CUDA Toolkit (defined if not set).
         CUDA_SDK_ROOT_DIR     -- Path to the CUDA SDK.  Use this to find files in the
                                  SDK.  This script will not directly support finding
                                  specific libraries or headers, as that isn't
                                  supported by NVIDIA.  If you want to change
                                  libraries when the path changes see the
                                  FindCUDA.cmake script for an example of how to clear
                                  these variables.  There are also examples of how to
                                  use the CUDA_SDK_ROOT_DIR to locate headers or
                                  libraries, if you so choose (at your own risk).
         CUDA_INCLUDE_DIRS     -- Include directory for cuda headers.  Added automatically
                                  for CUDA_ADD_EXECUTABLE and CUDA_ADD_LIBRARY.
         CUDA_LIBRARIES        -- Cuda RT library.
         CUDA_CUFFT_LIBRARIES  -- Device or emulation library for the Cuda FFT
                                  implementation (alternative to:
                                  CUDA_ADD_CUFFT_TO_TARGET macro)
         CUDA_CUBLAS_LIBRARIES -- Device or emulation library for the Cuda BLAS
                                  implementation (alterative to:
                                  CUDA_ADD_CUBLAS_TO_TARGET macro).

       

       

         James Bigler, NVIDIA Corp (nvidia.com - jbigler)
         Abe Stephens, SCI Institute -- http://www.sci.utah.edu/~abe/FindCuda.html

       

         Copyright (c) 2008 - 2009 NVIDIA Corporation.  All rights reserved.

       

         Copyright (c) 2007-2009
         Scientific Computing and Imaging Institute, University of Utah

       

         This code is licensed under the MIT License.  See the FindCUDA.cmake script
         for the text of the license.


  FindCURL
       Find curl

       Find the native CURL headers and libraries.

         CURL_INCLUDE_DIRS - where to find curl/curl.h, etc.
         CURL_LIBRARIES    - List of libraries when using curl.
         CURL_FOUND        - True if curl found.


  FindCVS
        

       The module defines the following variables:

          CVS_EXECUTABLE - path to cvs command line client
          CVS_FOUND - true if the command line client was found

       Example usage:

          find_package(CVS)
          if(CVS_FOUND)
            message("CVS found: ${CVS_EXECUTABLE}")
          endif(CVS_FOUND)


  FindCoin3D
       Find Coin3D (Open Inventor)

       Coin3D is an implementation of the Open Inventor API.  It provides
       data structures and algorithms for 3D visualization
       http://www.coin3d.org/

       This module defines the following variables

         COIN3D_FOUND         - system has Coin3D - Open Inventor
         COIN3D_INCLUDE_DIRS  - where the Inventor include directory can be found
         COIN3D_LIBRARIES     - Link to this to use Coin3D

       


  FindCups
       Try to find the Cups printing system

       Once done this will define

         CUPS_FOUND - system has Cups
         CUPS_INCLUDE_DIR - the Cups include directory
         CUPS_LIBRARIES - Libraries needed to use Cups
         Set CUPS_REQUIRE_IPP_DELETE_ATTRIBUTE to TRUE if you need a version which 
         features this function (i.e. at least 1.1.19)


  FindCurses
       Find the curses include file and library

       

         CURSES_FOUND - system has Curses
         CURSES_INCLUDE_DIR - the Curses include directory
         CURSES_LIBRARIES - The libraries needed to use Curses
         CURSES_HAVE_CURSES_H - true if curses.h is available
         CURSES_HAVE_NCURSES_H - true if ncurses.h is available
         CURSES_HAVE_NCURSES_NCURSES_H - true if ncurses/ncurses.h is available
         CURSES_HAVE_NCURSES_CURSES_H - true if ncurses/curses.h is available
         CURSES_LIBRARY - set for backwards compatibility with 2.4 CMake

       

       Set CURSES_NEED_NCURSES to TRUE before the FIND_PACKAGE() command if
       NCurses functionality is required.

  FindCxxTest
       Find CxxTest

       Find the CxxTest suite and declare a helper macro for creating unit
       tests and integrating them with CTest.  For more details on CxxTest
       see http://cxxtest.tigris.org

       INPUT Variables

          CXXTEST_USE_PYTHON
              If true, the CXXTEST_ADD_TEST macro will use
              the Python test generator instead of Perl.

       

       OUTPUT Variables

          CXXTEST_FOUND
              True if the CxxTest framework was found
          CXXTEST_INCLUDE_DIR
              Where to find the CxxTest include directory
          CXXTEST_PERL_TESTGEN_EXECUTABLE
              The perl-based test generator.
          CXXTEST_PYTHON_TESTGEN_EXECUTABLE
              The python-based test generator.

       

       MACROS for optional use by CMake users:

           CXXTEST_ADD_TEST(<test_name> <gen_source_file> <input_files_to_testgen...>)
              Creates a CxxTest runner and adds it to the CTest testing suite
              Parameters:
                  test_name               The name of the test
                  gen_source_file         The generated source filename to be generated by CxxTest
                  input_files_to_testgen  The list of header files containing the
                                          CxxTest::TestSuite's to be included in this runner
                  
              #==============
              Example Usage:

       

                  find_package(CxxTest)
                  if(CXXTEST_FOUND)
                      include_directories(${CXXTEST_INCLUDE_DIR})
                      enable_testing()

       

                      CXXTEST_ADD_TEST(unittest_foo foo_test.cc
                                        ${CMAKE_CURRENT_SOURCE_DIR}/foo_test.h)
                      target_link_libraries(unittest_foo foo) # as needed
                  endif()

       

                     This will (if CxxTest is found):
                     1. Invoke the testgen executable to autogenerate foo_test.cc in the
                        binary tree from "foo_test.h" in the current source directory.
                     2. Create an executable and test called unittest_foo.
                      
             #=============
             Example foo_test.h:

       

                 #include <cxxtest/TestSuite.h>
                 
                 class MyTestSuite : public CxxTest::TestSuite 
                 {
                 public:
                    void testAddition( void )
                    {
                       TS_ASSERT( 1 + 1 > 1 );
                       TS_ASSERT_EQUALS( 1 + 1, 2 );
                    }
                 };

       


  FindCygwin
       this module looks for Cygwin

       


  FindDCMTK
       find DCMTK libraries

       


  FindDart
       Find DART

       This module looks for the dart testing software and sets DART_ROOT to
       point to where it found it.


  FindDevIL
        

       This module locates the developer's image library.
       http://openil.sourceforge.net/

       This module sets: IL_LIBRARIES the name of the IL library.  These
       include the full path to the core DevIL library.  This one has to be
       linked into the application.  ILU_LIBRARIES the name of the ILU
       library.  Again, the full path.  This library is for filters and
       effects, not actual loading.  It doesn't have to be linked if the
       functionality it provides is not used.  ILUT_LIBRARIES the name of the
       ILUT library.  Full path.  This part of the library interfaces with
       OpenGL.  It is not strictly needed in applications.  IL_INCLUDE_DIR
       where to find the il.h, ilu.h and ilut.h files.  IL_FOUND this is set
       to TRUE if all the above variables were set.  This will be set to
       false if ILU or ILUT are not found, even if they are not needed.  In
       most systems, if one library is found all the others are as well.
       That's the way the DevIL developers release it.

  FindDoxygen
       This module looks for Doxygen and the path to Graphviz's dot

       Doxygen is a documentation generation tool.  Please see
       http://www.doxygen.org

       This module accepts the following optional variables:

          DOXYGEN_SKIP_DOT       = If true this module will skip trying to find Dot
                                   (an optional component often used by Doxygen)

       

       This modules defines the following variables:

          DOXYGEN_EXECUTABLE     = The path to the doxygen command.
          DOXYGEN_FOUND          = Was Doxygen found or not?

       

          DOXYGEN_DOT_EXECUTABLE = The path to the dot program used by doxygen.
          DOXYGEN_DOT_FOUND      = Was Dot found or not?
          DOXYGEN_DOT_PATH       = The path to dot not including the executable

       

       


  FindEXPAT
       Find expat

       Find the native EXPAT headers and libraries.

         EXPAT_INCLUDE_DIRS - where to find expat.h, etc.
         EXPAT_LIBRARIES    - List of libraries when using expat.
         EXPAT_FOUND        - True if expat found.


  FindFLEX
       Find flex executable and provides a macro to generate custom build
       rules

       

       The module defines the following variables:

         FLEX_FOUND - true is flex executable is found
         FLEX_EXECUTABLE - the path to the flex executable
         FLEX_VERSION - the version of flex
         FLEX_LIBRARIES - The flex libraries

       

       If flex is found on the system, the module provides the macro:

         FLEX_TARGET(Name FlexInput FlexOutput [COMPILE_FLAGS <string>])

       which creates a custom command to generate the <FlexOutput> file from
       the <FlexInput> file.  If COMPILE_FLAGS option is specified, the next
       parameter is added to the flex command line.  Name is an alias used to
       get details of this custom command.  Indeed the macro defines the
       following variables:

         FLEX_${Name}_DEFINED - true is the macro ran successfully
         FLEX_${Name}_OUTPUTS - the source file generated by the custom rule, an
         alias for FlexOutput
         FLEX_${Name}_INPUT - the flex source file, an alias for ${FlexInput}

       

       Flex scanners oftenly use tokens defined by Bison: the code generated
       by Flex depends of the header generated by Bison.  This module also
       defines a macro:

         ADD_FLEX_BISON_DEPENDENCY(FlexTarget BisonTarget)

       which adds the required dependency between a scanner and a parser
       where <FlexTarget> and <BisonTarget> are the first parameters of
       respectively FLEX_TARGET and BISON_TARGET macros.

         ====================================================================
         Example:

       

          find_package(BISON)
          find_package(FLEX)

       

          BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp
          FLEX_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BIANRY_DIR}/lexer.cpp)
          ADD_FLEX_BISON_DEPENDENCY(MyScanner MyParser)

       

          include_directories(${CMAKE_CURRENT_BINARY_DIR})
          add_executable(Foo
             Foo.cc
             ${BISON_MyParser_OUTPUTS}
             ${FLEX_MyScanner_OUTPUTS}
          )
         ====================================================================


  FindFLTK
       Find the native FLTK includes and library

       

       By default FindFLTK.cmake will search for all of the FLTK components
       and add them to the FLTK_LIBRARIES variable.

          You can limit the components which get placed in FLTK_LIBRARIES by
          defining one or more of the following three options:

       

            FLTK_SKIP_OPENGL, set to true to disable searching for opengl and
                              the FLTK GL library
            FLTK_SKIP_FORMS, set to true to disable searching for fltk_forms
            FLTK_SKIP_IMAGES, set to true to disable searching for fltk_images

       

            FLTK_SKIP_FLUID, set to true if the fluid binary need not be present
                             at build time

       

       The following variables will be defined:

            FLTK_FOUND, True if all components not skipped were found
            FLTK_INCLUDE_DIR, where to find include files
            FLTK_LIBRARIES, list of fltk libraries you should link against
            FLTK_FLUID_EXECUTABLE, where to find the Fluid tool
            FLTK_WRAP_UI, This enables the FLTK_WRAP_UI command

       

       The following cache variables are assigned but should not be used.
       See the FLTK_LIBRARIES variable instead.

            FLTK_BASE_LIBRARY   = the full path to fltk.lib
            FLTK_GL_LIBRARY     = the full path to fltk_gl.lib
            FLTK_FORMS_LIBRARY  = the full path to fltk_forms.lib
            FLTK_IMAGES_LIBRARY = the full path to fltk_images.lib


  FindFLTK2
       Find the native FLTK2 includes and library

       The following settings are defined

         FLTK2_FLUID_EXECUTABLE, where to find the Fluid tool
         FLTK2_WRAP_UI, This enables the FLTK2_WRAP_UI command
         FLTK2_INCLUDE_DIR, where to find include files
         FLTK2_LIBRARIES, list of fltk2 libraries
         FLTK2_FOUND, Don't use FLTK2 if false.

       The following settings should not be used in general.

         FLTK2_BASE_LIBRARY   = the full path to fltk2.lib
         FLTK2_GL_LIBRARY     = the full path to fltk2_gl.lib
         FLTK2_IMAGES_LIBRARY = the full path to fltk2_images.lib


  FindFreetype
       Locate FreeType library

       This module defines

         FREETYPE_LIBRARIES, the library to link against
         FREETYPE_FOUND, if false, do not try to link to FREETYPE
         FREETYPE_INCLUDE_DIRS, where to find headers.
         This is the concatenation of the paths:
         FREETYPE_INCLUDE_DIR_ft2build
         FREETYPE_INCLUDE_DIR_freetype2

       

       $FREETYPE_DIR is an environment variable that would correspond to the
       ./configure --prefix=$FREETYPE_DIR used in building FREETYPE.

  FindGCCXML
       Find the GCC-XML front-end executable.

  FindGDAL
        

       Locate gdal

       This module accepts the following environment variables:

           GDAL_DIR or GDAL_ROOT - Specify the location of GDAL

       

       This module defines the following CMake variables:

           GDAL_FOUND - True if libgdal is found
           GDAL_LIBRARY - A variable pointing to the GDAL library
           GDAL_INCLUDE_DIR - Where to find the headers


  FindGIF
        

       This module defines GIF_LIBRARIES - libraries to link to in order to
       use GIF GIF_FOUND, if false, do not try to link GIF_INCLUDE_DIR, where
       to find the headers

       $GIF_DIR is an environment variable that would correspond to the
       ./configure --prefix=$GIF_DIR

  FindGLUT
       try to find glut library and include files

         GLUT_INCLUDE_DIR, where to find GL/glut.h, etc.
         GLUT_LIBRARIES, the libraries to link against
         GLUT_FOUND, If false, do not try to use GLUT.

       Also defined, but not for general use are:

         GLUT_glut_LIBRARY = the full path to the glut library.
         GLUT_Xmu_LIBRARY  = the full path to the Xmu library.
         GLUT_Xi_LIBRARY   = the full path to the Xi Library.


  FindGTK
       try to find GTK (and glib) and GTKGLArea

         GTK_INCLUDE_DIR   - Directories to include to use GTK
         GTK_LIBRARIES     - Files to link against to use GTK
         GTK_FOUND         - GTK was found
         GTK_GL_FOUND      - GTK's GL features were found


  FindGTK2
       FindGTK2.cmake

       This module can find the GTK2 widget libraries and several of its
       other optional components like gtkmm, glade, and glademm.

       NOTE: If you intend to use version checking, CMake 2.6.2 or later is

              required.

       

       Specify one or more of the following components as you call this find
       module.  See example below.

          gtk
          gtkmm
          glade
          glademm

       

       The following variables will be defined for your use

          GTK2_FOUND - Were all of your specified components found?
          GTK2_INCLUDE_DIRS - All include directories
          GTK2_LIBRARIES - All libraries

       

          GTK2_VERSION - The version of GTK2 found (x.y.z)
          GTK2_MAJOR_VERSION - The major version of GTK2
          GTK2_MINOR_VERSION - The minor version of GTK2
          GTK2_PATCH_VERSION - The patch version of GTK2

       

       Optional variables you can define prior to calling this module:

          GTK2_DEBUG - Enables verbose debugging of the module
          GTK2_SKIP_MARK_AS_ADVANCED - Disable marking cache variables as advanced

       

       ================= Example Usage:

          Call find_package() once, here are some examples to pick from:

       

          Require GTK 2.6 or later
              find_package(GTK2 2.6 REQUIRED gtk)

       

          Require GTK 2.10 or later and Glade
              find_package(GTK2 2.10 REQUIRED gtk glade)

       

          Search for GTK/GTKMM 2.8 or later
              find_package(GTK2 2.8 COMPONENTS gtk gtkmm)

       

          if(GTK2_FOUND)
             include_directories(${GTK2_INCLUDE_DIRS})
             add_executable(mygui mygui.cc)
             target_link_libraries(mygui ${GTK2_LIBRARIES})
          endif()

       


  FindGTest
       --------------------

       Locate the Google C++ Testing Framework.

       Defines the following variables:

          GTEST_FOUND - Found the Google Testing framework
          GTEST_INCLUDE_DIRS - Include directories

       

       Also defines the library variables below as normal variables.  These
       contain debug/optimized keywords when a debugging library is found.

          GTEST_BOTH_LIBRARIES - Both libgtest & libgtest-main
          GTEST_LIBRARIES - libgtest
          GTEST_MAIN_LIBRARIES - libgtest-main

       

       Accepts the following variables as input:

          GTEST_ROOT - (as CMake or env. variable)
                       The root directory of the gtest install prefix

       

          GTEST_MSVC_SEARCH - If on MSVC, enables searching the build tree of
                              GTest if set to MD or MT (defaults: MD)

       

       Example Usage:

           enable_testing(true)
           find_package(GTest REQUIRED)
           include_directories(${GTEST_INCLUDE_DIRS})

       

           add_executable(foo foo.cc)
           target_link_libraries(foo ${GTEST_BOTH_LIBRARIES})

       

           add_test(AllTestsInFoo foo)

       

       

       If you would like each Google test to show up in CTest as a test you
       may use the following macro.  NOTE: It WILL slow down your tests, so
       be warned.

       GTEST_ADD_TESTS(executable extra_args ARGN)

           executable = The path to the test executable
           extra_args = Pass a list of extra arguments to be passed to
                        executable enclosed in quotes (or "" for none)
           ARGN =       A list of source files to search for tests & test
                        fixtures.

       

         Example:
            set(FooTestArgs --foo 1 --bar 2)
            add_executable(FooTest FooUnitTest.cc)
            GTEST_ADD_TESTS(FooTest "${FooTestArgs}" FooUnitTest.cc)


  FindGettext
       Find GNU gettext tools

       This module looks for the GNU gettext tools.  This module defines the
       following values:

         GETTEXT_MSGMERGE_EXECUTABLE: the full path to the msgmerge tool.
         GETTEXT_MSGFMT_EXECUTABLE: the full path to the msgfmt tool.
         GETTEXT_FOUND: True if gettext has been found.

       

       Additionally it provides the following macros:
       GETTEXT_CREATE_TRANSLATIONS ( outputFile [ALL] file1 ...  fileN )

           This will create a target "translations" which will convert the 
           given input po files into the binary output mo file. If the 
           ALL option is used, the translations will also be created when
           building the default target.


  FindGnuTLS
       Try to find the GNU Transport Layer Security library (gnutls)

       

       Once done this will define

         GNUTLS_FOUND - System has gnutls
         GNUTLS_INCLUDE_DIR - The gnutls include directory
         GNUTLS_LIBRARIES - The libraries needed to use gnutls
         GNUTLS_DEFINITIONS - Compiler switches required for using gnutls


  FindGnuplot
       this module looks for gnuplot

       

       Once done this will define

         GNUPLOT_FOUND - system has Gnuplot
         GNUPLOT_EXECUTABLE - the Gnuplot executable


  FindHDF5
       Find HDF5, a library for reading and writing self describing array
       data.

       

       This module invokes the HDF5 wrapper compiler that should be installed
       alongside HDF5.  Depending upon the HDF5 Configuration, the wrapper
       compiler is called either h5cc or h5pcc.  If this succeeds, the module
       will then call the compiler with the -show argument to see what flags
       are used when compiling an HDF5 client application.

       The module will optionally accept the COMPONENTS argument.  If no
       COMPONENTS are specified, then the find module will default to finding
       only the HDF5 C library.  If one or more COMPONENTS are specified, the
       module will attempt to find the language bindings for the specified
       components.  Currently, the only valid components are C and CXX.  The
       module does not yet support finding the Fortran bindings.  If the
       COMPONENTS argument is not given, the module will attempt to find only
       the C bindings.

       On UNIX systems, this module will read the variable
       HDF5_USE_STATIC_LIBRARIES to determine whether or not to prefer a
       static link to a dynamic link for HDF5 and all of it's dependencies.
       To use this feature, make sure that the HDF5_USE_STATIC_LIBRARIES
       variable is set before the call to find_package.

       To provide the module with a hint about where to find your HDF5
       installation, you can set the environment variable HDF5_ROOT.  The
       Find module will then look in this path when searching for HDF5
       executables, paths, and libraries.

       In addition to finding the includes and libraries required to compile
       an HDF5 client application, this module also makes an effort to find
       tools that come with the HDF5 distribution that may be useful for
       regression testing.

       This module will define the following variables:

         HDF5_INCLUDE_DIR - Location of the hdf5 includes
         HDF5_DEFINITIONS - Required compiler definitions for HDF5
         HDF5_C_LIBRARIES - Required libraries for the HDF5 C bindings.
         HDF5_CXX_LIBRARIES - Required libraries for the HDF5 C++ bindings
         HDF5_LIBRARIES - Required libraries for all requested bindings
         HDF5_FOUND - true if HDF5 was found on the system
         HDF5_LIBRARY_DIRS - the full set of library directories
         HDF5_IS_PARALLEL - Whether or not HDF5 was found with parallel IO support
         HDF5_C_COMPILER_EXECUTABLE - the path to the HDF5 C wrapper compiler
         HDF5_CXX_COMPILER_EXECUTABLE - the path to the HDF5 C++ wrapper compiler
         HDF5_DIFF_EXECUTABLE - the path to the HDF5 dataset comparison tool


  FindHSPELL
       Try to find HSPELL

       Once done this will define

         HSPELL_FOUND - system has HSPELL
         HSPELL_INCLUDE_DIR - the HSPELL include directory
         HSPELL_LIBRARIES - The libraries needed to use HSPELL
         HSPELL_DEFINITIONS - Compiler switches required for using HSPELL


  FindHTMLHelp
       This module looks for Microsoft HTML Help Compiler

       It defines:

          HTML_HELP_COMPILER     : full path to the Compiler (hhc.exe)
          HTML_HELP_INCLUDE_PATH : include path to the API (htmlhelp.h)
          HTML_HELP_LIBRARY      : full path to the library (htmlhelp.lib)

       


  FindITK
       Find an ITK installation or build tree.

  FindImageMagick
       Find the ImageMagick binary suite.

       This module will search for a set of ImageMagick tools specified as
       components in the FIND_PACKAGE call.  Typical components include, but
       are not limited to (future versions of ImageMagick might have
       additional components not listed here):

         animate
         compare
         composite
         conjure
         convert
         display
         identify
         import
         mogrify
         montage
         stream

       

       If no component is specified in the FIND_PACKAGE call, then it only
       searches for the ImageMagick executable directory.  This code defines
       the following variables:

         ImageMagick_FOUND                  - TRUE if all components are found.
         ImageMagick_EXECUTABLE_DIR         - Full path to executables directory.
         ImageMagick_<component>_FOUND      - TRUE if <component> is found.
         ImageMagick_<component>_EXECUTABLE - Full path to <component> executable.

       

       There are also components for the following ImageMagick APIs:

         Magick++
         MagickWand
         MagickCore

       

       For these components the following variables are set:

         ImageMagick_FOUND                    - TRUE if all components are found.
         ImageMagick_INCLUDE_DIRS             - Full paths to all include dirs.
         ImageMagick_LIBRARIES                - Full paths to all libraries.
         ImageMagick_<component>_FOUND        - TRUE if <component> is found.
         ImageMagick_<component>_INCLUDE_DIRS - Full path to <component> include dirs.
         ImageMagick_<component>_LIBRARIES    - Full path to <component> libraries.

       

       Example Usages:

         FIND_PACKAGE(ImageMagick)
         FIND_PACKAGE(ImageMagick COMPONENTS convert)
         FIND_PACKAGE(ImageMagick COMPONENTS convert mogrify display)
         FIND_PACKAGE(ImageMagick COMPONENTS Magick++)
         FIND_PACKAGE(ImageMagick COMPONENTS Magick++ convert)

       

       Note that the standard FIND_PACKAGE features are supported (i.e.,
       QUIET, REQUIRED, etc.).

  FindJNI
       Find JNI java libraries.

       This module finds if Java is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

          
         JNI_INCLUDE_DIRS      = the include dirs to use
         JNI_LIBRARIES         = the libraries to use
         JAVA_AWT_LIBRARY      = the path to the jawt library
         JAVA_JVM_LIBRARY      = the path to the jvm library
         JAVA_INCLUDE_PATH     = the include path to jni.h
         JAVA_INCLUDE_PATH2    = the include path to jni_md.h
         JAVA_AWT_INCLUDE_PATH = the include path to jawt.h

       


  FindJPEG
       Find JPEG

       Find the native JPEG includes and library This module defines

         JPEG_INCLUDE_DIR, where to find jpeglib.h, etc.
         JPEG_LIBRARIES, the libraries needed to use JPEG.
         JPEG_FOUND, If false, do not try to use JPEG.

       also defined, but not for general use are

         JPEG_LIBRARY, where to find the JPEG library.


  FindJasper
       Try to find the Jasper JPEG2000 library

       Once done this will define

         JASPER_FOUND - system has Jasper
         JASPER_INCLUDE_DIR - the Jasper include directory
         JASPER_LIBRARIES - The libraries needed to use Jasper


  FindJava
       Find Java

       This module finds if Java is installed and determines where the
       include files and libraries are.  This code sets the following
       variables:

         JAVA_RUNTIME    = the full path to the Java runtime
         JAVA_COMPILE    = the full path to the Java compiler
         JAVA_ARCHIVE    = the full path to the Java archiver

       


  FindKDE3
       Find the KDE3 include and library dirs, KDE preprocessors and define a
       some macros

       

       This module defines the following variables:

         KDE3_DEFINITIONS         - compiler definitions required for compiling KDE software
         KDE3_INCLUDE_DIR         - the KDE include directory
         KDE3_INCLUDE_DIRS        - the KDE and the Qt include directory, for use with INCLUDE_DIRECTORIES()
         KDE3_LIB_DIR             - the directory where the KDE libraries are installed, for use with LINK_DIRECTORIES()
         QT_AND_KDECORE_LIBS      - this contains both the Qt and the kdecore library
         KDE3_DCOPIDL_EXECUTABLE  - the dcopidl executable
         KDE3_DCOPIDL2CPP_EXECUTABLE - the dcopidl2cpp executable
         KDE3_KCFGC_EXECUTABLE    - the kconfig_compiler executable
         KDE3_FOUND               - set to TRUE if all of the above has been found

       

       The following user adjustable options are provided:

         KDE3_BUILD_TESTS - enable this to build KDE testcases

       

       

       It also adds the following macros (from KDE3Macros.cmake) SRCS_VAR is
       always the variable which contains the list of source files for your
       application or library.

       KDE3_AUTOMOC(file1 ...  fileN)

           Call this if you want to have automatic moc file handling.
           This means if you include "foo.moc" in the source file foo.cpp
           a moc file for the header foo.h will be created automatically.
           You can set the property SKIP_AUTOMAKE using SET_SOURCE_FILES_PROPERTIES()
           to exclude some files in the list from being processed.

       

       KDE3_ADD_MOC_FILES(SRCS_VAR file1 ...  fileN )

           If you don't use the KDE3_AUTOMOC() macro, for the files
           listed here moc files will be created (named "foo.moc.cpp")

       

       KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h ...  headerN.h )

           Use this to generate DCOP skeletions from the listed headers.

       

       KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h ...  headerN.h )

            Use this to generate DCOP stubs from the listed headers.

       

       KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ...  fileN.ui )

           Use this to add the Qt designer ui files to your application/library.

       

       KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc ...  fileN.kcfgc )

           Use this to add KDE kconfig compiler files to your application/library.

       

       KDE3_INSTALL_LIBTOOL_FILE(target)

           This will create and install a simple libtool file for the given target.

       

       KDE3_ADD_EXECUTABLE(name file1 ...  fileN )

           Currently identical to ADD_EXECUTABLE(), may provide some advanced features in the future.

       

       KDE3_ADD_KPART(name [WITH_PREFIX] file1 ...  fileN )

           Create a KDE plugin (KPart, kioslave, etc.) from the given source files.
           If WITH_PREFIX is given, the resulting plugin will have the prefix "lib", otherwise it won't.
           It creates and installs an appropriate libtool la-file.

       

       KDE3_ADD_KDEINIT_EXECUTABLE(name file1 ...  fileN )

           Create a KDE application in the form of a module loadable via kdeinit.
           A library named kdeinit_<name> will be created and a small executable which links to it.

       

       The option KDE3_ENABLE_FINAL to enable all-in-one compilation is no
       longer supported.

       

       Author: Alexander Neundorf <neundorf@kde.org>

  FindKDE4
        

       Find KDE4 and provide all necessary variables and macros to compile
       software for it.  It looks for KDE 4 in the following directories in
       the given order:

         CMAKE_INSTALL_PREFIX
         KDEDIRS
         /opt/kde4

       

       Please look in FindKDE4Internal.cmake and KDE4Macros.cmake for more
       information.  They are installed with the KDE 4 libraries in
       $KDEDIRS/share/apps/cmake/modules/.

       Author: Alexander Neundorf <neundorf@kde.org>

  FindLAPACK
       Find LAPACK library

       This module finds an installed fortran library that implements the
       LAPACK linear-algebra interface (see http://www.netlib.org/lapack/).

       The approach follows that taken for the autoconf macro file,
       acx_lapack.m4 (distributed at
       http://ac-archive.sourceforge.net/ac-archive/acx_lapack.html).

       This module sets the following variables:

         LAPACK_FOUND - set to true if a library implementing the LAPACK interface
           is found
         LAPACK_LINKER_FLAGS - uncached list of required linker flags (excluding -l
           and -L).
         LAPACK_LIBRARIES - uncached list of libraries (using full path name) to
           link against to use LAPACK
         LAPACK95_LIBRARIES - uncached list of libraries (using full path name) to
           link against to use LAPACK95
         LAPACK95_FOUND - set to true if a library implementing the LAPACK f95
           interface is found
         BLA_STATIC  if set on this determines what kind of linkage we do (static)
         BLA_VENDOR  if set checks only the specified vendor, if not set checks
            all the possibilities
         BLA_F95     if set on tries to find the f95 interfaces for BLAS/LAPACK

       ## List of vendors (BLA_VENDOR) valid in this module # Intel(mkl),
       ACML,Apple, NAS, Generic

  FindLATEX
       Find Latex

       This module finds if Latex is installed and determines where the
       executables are.  This code sets the following variables:

         
         LATEX_COMPILER:       path to the LaTeX compiler
         PDFLATEX_COMPILER:    path to the PdfLaTeX compiler
         BIBTEX_COMPILER:      path to the BibTeX compiler
         MAKEINDEX_COMPILER:   path to the MakeIndex compiler
         DVIPS_CONVERTER:      path to the DVIPS converter
         PS2PDF_CONVERTER:     path to the PS2PDF converter
         LATEX2HTML_CONVERTER: path to the LaTeX2Html converter 

       


  FindLibXml2
       Try to find LibXml2

       Once done this will define

         LIBXML2_FOUND - System has LibXml2
         LIBXML2_INCLUDE_DIR - The LibXml2 include directory
         LIBXML2_LIBRARIES - The libraries needed to use LibXml2
         LIBXML2_DEFINITIONS - Compiler switches required for using LibXml2
         LIBXML2_XMLLINT_EXECUTABLE - The XML checking tool xmllint coming with LibXml2


  FindLibXslt
       Try to find LibXslt

       Once done this will define

         LIBXSLT_FOUND - system has LibXslt
         LIBXSLT_INCLUDE_DIR - the LibXslt include directory
         LIBXSLT_LIBRARIES - Link these to LibXslt
         LIBXSLT_DEFINITIONS - Compiler switches required for using LibXslt


  FindLua50
        

       Locate Lua library This module defines

         LUA50_FOUND, if false, do not try to link to Lua 
         LUA_LIBRARIES, both lua and lualib
         LUA_INCLUDE_DIR, where to find lua.h and lualib.h (and probably lauxlib.h)

       

       Note that the expected include convention is

         #include "lua.h"

       and not

         #include <lua/lua.h>

       This is because, the lua location is not standardized and may exist in
       locations other than lua/

  FindLua51
        

       Locate Lua library This module defines

         LUA51_FOUND, if false, do not try to link to Lua 
         LUA_LIBRARIES
         LUA_INCLUDE_DIR, where to find lua.h 

       

       Note that the expected include convention is

         #include "lua.h"

       and not

         #include <lua/lua.h>

       This is because, the lua location is not standardized and may exist in
       locations other than lua/

  FindMFC
       Find MFC on Windows

       Find the native MFC - i.e.  decide if an application can link to the
       MFC libraries.

         MFC_FOUND - Was MFC support found

       You don't need to include anything or link anything to use it.

  FindMPEG
       Find the native MPEG includes and library

       This module defines

         MPEG_INCLUDE_DIR, where to find MPEG.h, etc.
         MPEG_LIBRARIES, the libraries required to use MPEG.
         MPEG_FOUND, If false, do not try to use MPEG.

       also defined, but not for general use are

         MPEG_mpeg2_LIBRARY, where to find the MPEG library.
         MPEG_vo_LIBRARY, where to find the vo library.


  FindMPEG2
       Find the native MPEG2 includes and library

       This module defines

         MPEG2_INCLUDE_DIR, path to mpeg2dec/mpeg2.h, etc.
         MPEG2_LIBRARIES, the libraries required to use MPEG2.
         MPEG2_FOUND, If false, do not try to use MPEG2.

       also defined, but not for general use are

         MPEG2_mpeg2_LIBRARY, where to find the MPEG2 library.
         MPEG2_vo_LIBRARY, where to find the vo library.


  FindMPI
       Message Passing Interface (MPI) module.

       

       The Message Passing Interface (MPI) is a library used to write
       high-performance parallel applications that use message passing, and
       is typically deployed on a cluster.  MPI is a standard interface
       (defined by the MPI forum) for which many implementations are
       available.  All of these implementations have somewhat different
       compilation approaches (different include paths, libraries to link
       against, etc.), and this module tries to smooth out those differences.

       This module will set the following variables:

          MPI_FOUND                  TRUE if we have found MPI
          MPI_COMPILE_FLAGS          Compilation flags for MPI programs
          MPI_INCLUDE_PATH           Include path(s) for MPI header
          MPI_LINK_FLAGS             Linking flags for MPI programs
          MPI_LIBRARY                First MPI library to link against (cached)
          MPI_EXTRA_LIBRARY          Extra MPI libraries to link against (cached)
          MPI_LIBRARIES              All libraries to link MPI programs against
          MPIEXEC                    Executable for running MPI programs
          MPIEXEC_NUMPROC_FLAG       Flag to pass to MPIEXEC before giving it the
                                     number of processors to run on
          MPIEXEC_PREFLAGS           Flags to pass to MPIEXEC directly before the
                                     executable to run.
          MPIEXEC_POSTFLAGS          Flags to pass to MPIEXEC after all other flags.

       

       This module will attempt to auto-detect these settings, first by
       looking for a MPI compiler, which many MPI implementations provide as
       a pass-through to the native compiler to simplify the compilation of
       MPI programs.  The MPI compiler is stored in the cache variable
       MPI_COMPILER, and will attempt to look for commonly-named drivers
       mpic++, mpicxx, mpiCC, or mpicc.  If the compiler driver is found and
       recognized, it will be used to set all of the module variables.  To
       skip this auto-detection, set MPI_LIBRARY and MPI_INCLUDE_PATH in the
       CMake cache.

       If no compiler driver is found or the compiler driver is not
       recognized, this module will then search for common include paths and
       library names to try to detect MPI.

       If CMake initially finds a different MPI than was intended, and you
       want to use the MPI compiler auto-detection for a different MPI
       implementation, set MPI_COMPILER to the MPI compiler driver you want
       to use (e.g., mpicxx) and then set MPI_LIBRARY to the string
       MPI_LIBRARY-NOTFOUND.  When you re-configure, auto-detection of MPI
       will run again with the newly-specified MPI_COMPILER.

       When using MPIEXEC to execute MPI applications, you should typically
       use all of the MPIEXEC flags as follows:

          ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} PROCS ${MPIEXEC_PREFLAGS} EXECUTABLE
            ${MPIEXEC_POSTFLAGS} ARGS

       where PROCS is the number of processors on which to execute the
       program, EXECUTABLE is the MPI program, and ARGS are the arguments to
       pass to the MPI program.

  FindMatlab
       this module looks for Matlab

       Defines:

         MATLAB_INCLUDE_DIR: include path for mex.h, engine.h
         MATLAB_LIBRARIES:   required libraries: libmex, etc
         MATLAB_MEX_LIBRARY: path to libmex.lib
         MATLAB_MX_LIBRARY:  path to libmx.lib
         MATLAB_ENG_LIBRARY: path to libeng.lib


  FindMotif
       Try to find Motif (or lesstif)

       Once done this will define:

         MOTIF_FOUND        - system has MOTIF
         MOTIF_INCLUDE_DIR  - include paths to use Motif
         MOTIF_LIBRARIES    - Link these to use Motif


  FindOpenAL
        

       Locate OpenAL This module defines OPENAL_LIBRARY OPENAL_FOUND, if
       false, do not try to link to OpenAL OPENAL_INCLUDE_DIR, where to find
       the headers

       $OPENALDIR is an environment variable that would correspond to the
       ./configure --prefix=$OPENALDIR used in building OpenAL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module.

  FindOpenGL
       Try to find OpenGL

       Once done this will define

         
         OPENGL_FOUND        - system has OpenGL
         OPENGL_XMESA_FOUND  - system has XMESA
         OPENGL_GLU_FOUND    - system has GLU
         OPENGL_INCLUDE_DIR  - the GL include directory
         OPENGL_LIBRARIES    - Link these to use OpenGL and GLU
          

       If you want to use just GL you can use these values

         OPENGL_gl_LIBRARY   - Path to OpenGL Library
         OPENGL_glu_LIBRARY  - Path to GLU Library
         

       On OSX default to using the framework version of opengl People will
       have to change the cache values of OPENGL_glu_LIBRARY and
       OPENGL_gl_LIBRARY to use OpenGL with X11 on OSX

  FindOpenMP
       Finds OpenMP support

       This module can be used to detect OpenMP support in a compiler.  If
       the compiler supports OpenMP, the flags required to compile with
       openmp support are set.

       The following variables are set:

          OpenMP_C_FLAGS - flags to add to the C compiler for OpenMP support
          OpenMP_CXX_FLAGS - flags to add to the CXX compiler for OpenMP support
          OPENMP_FOUND - true if openmp is detected

       

       Supported compilers can be found at
       http://openmp.org/wp/openmp-compilers/

  FindOpenSSL
       Try to find the OpenSSL encryption library

       Once done this will define

         OPENSSL_FOUND - system has the OpenSSL library
         OPENSSL_INCLUDE_DIR - the OpenSSL include directory
         OPENSSL_LIBRARIES - The libraries needed to use OpenSSL


  FindOpenSceneGraph
       Find OpenSceneGraph

       This module searches for the OpenSceneGraph core "osg" library as well
       as OpenThreads, and whatever additional COMPONENTS (nodekits) that you
       specify.

           See http://www.openscenegraph.org

       

       NOTE: To use this module effectively you must either require CMake >=
       2.6.3 with cmake_minimum_required(VERSION 2.6.3) or download and place
       FindOpenThreads.cmake, Findosg_functions.cmake, Findosg.cmake, and
       Find<etc>.cmake files into your CMAKE_MODULE_PATH.

       ==================================

       This module accepts the following variables (note mixed case)

           OpenSceneGraph_DEBUG - Enable debugging output

       

           OpenSceneGraph_MARK_AS_ADVANCED - Mark cache variables as advanced 
                                             automatically

       

       The following environment variables are also respected for finding the
       OSG and it's various components.  CMAKE_PREFIX_PATH can also be used
       for this (see find_library() CMake documentation).

           <MODULE>_DIR (where MODULE is of the form "OSGVOLUME" and there is a FindosgVolume.cmake file)
           OSG_DIR
           OSGDIR
           OSG_ROOT

       

       This module defines the following output variables:

           OPENSCENEGRAPH_FOUND - Was the OSG and all of the specified components found?

       

           OPENSCENEGRAPH_VERSION - The version of the OSG which was found

       

           OPENSCENEGRAPH_INCLUDE_DIRS - Where to find the headers

       

           OPENSCENEGRAPH_LIBRARIES - The OSG libraries

       

       ================================== Example Usage:

         find_package(OpenSceneGraph 2.0.0 REQUIRED osgDB osgUtil)
             # libOpenThreads & libosg automatically searched
         include_directories(${OPENSCENEGRAPH_INCLUDE_DIRS})

       

         add_executable(foo foo.cc)
         target_link_libraries(foo ${OPENSCENEGRAPH_LIBRARIES})

       


  FindOpenThreads
        

       OpenThreads is a C++ based threading library.  Its largest userbase
       seems to OpenSceneGraph so you might notice I accept OSGDIR as an
       environment path.  I consider this part of the Findosg* suite used to
       find OpenSceneGraph components.  Each component is separate and you
       must opt in to each module.

       Locate OpenThreads This module defines OPENTHREADS_LIBRARY
       OPENTHREADS_FOUND, if false, do not try to link to OpenThreads
       OPENTHREADS_INCLUDE_DIR, where to find the headers

       $OPENTHREADS_DIR is an environment variable that would correspond to
       the ./configure --prefix=$OPENTHREADS_DIR used in building osg.

       Created by Eric Wing.

  FindPHP4
       Find PHP4

       This module finds if PHP4 is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PHP4_INCLUDE_PATH       = path to where php.h can be found
         PHP4_EXECUTABLE         = full path to the php4 binary

       


  FindPNG
       Find the native PNG includes and library

       

       This module defines

         PNG_INCLUDE_DIR, where to find png.h, etc.
         PNG_LIBRARIES, the libraries to link against to use PNG.
         PNG_DEFINITIONS - You should add_definitons(${PNG_DEFINITIONS}) before compiling code that includes png library files.
         PNG_FOUND, If false, do not try to use PNG.

       also defined, but not for general use are

         PNG_LIBRARY, where to find the PNG library.

       None of the above will be defined unles zlib can be found.  PNG
       depends on Zlib

  FindPackageHandleStandardArgs
        

       FIND_PACKAGE_HANDLE_STANDARD_ARGS(NAME (DEFAULT_MSG|"Custom failure
       message") VAR1 ...  )

           This macro is intended to be used in FindXXX.cmake modules files.
           It handles the REQUIRED and QUIET argument to FIND_PACKAGE() and
           it also sets the <UPPERCASED_NAME>_FOUND variable.
           The package is found if all variables listed are TRUE.
           Example:

       

           FIND_PACKAGE_HANDLE_STANDARD_ARGS(LibXml2 DEFAULT_MSG LIBXML2_LIBRARIES LIBXML2_INCLUDE_DIR)

       

           LibXml2 is considered to be found, if both LIBXML2_LIBRARIES and 
           LIBXML2_INCLUDE_DIR are valid. Then also LIBXML2_FOUND is set to TRUE.
           If it is not found and REQUIRED was used, it fails with FATAL_ERROR, 
           independent whether QUIET was used or not.
           If it is found, the location is reported using the VAR1 argument, so 
           here a message "Found LibXml2: /usr/lib/libxml2.so" will be printed out.
           If the second argument is DEFAULT_MSG, the message in the failure case will 
           be "Could NOT find LibXml2", if you don't like this message you can specify
           your own custom failure message there.


  FindPackageMessage
        

       FIND_PACKAGE_MESSAGE(<name> "message for user" "find result details")

       This macro is intended to be used in FindXXX.cmake modules files.  It
       will print a message once for each unique find result.  This is useful
       for telling the user where a package was found.  The first argument
       specifies the name (XXX) of the package.  The second argument
       specifies the message to display.  The third argument lists details
       about the find result so that if they change the message will be
       displayed again.  The macro also obeys the QUIET argument to the
       find_package command.

       Example:

         IF(X11_FOUND)
           FIND_PACKAGE_MESSAGE(X11 "Found X11: ${X11_X11_LIB}"
             "[${X11_X11_LIB}][${X11_INCLUDE_DIR}]")
         ELSE(X11_FOUND)
          ...
         ENDIF(X11_FOUND)


  FindPerl
       Find perl

       this module looks for Perl

         PERL_EXECUTABLE - the full path to perl
         PERL_FOUND      - If false, don't attempt to use perl.


  FindPerlLibs
       Find Perl libraries

       This module finds if PERL is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PERLLIBS_FOUND    = True if perl.h & libperl were found
         PERL_INCLUDE_PATH = path to where perl.h is found
         PERL_LIBRARY      = path to libperl
         PERL_EXECUTABLE   = full path to the perl binary

       

         The following variables are also available if needed
         (introduced after CMake 2.6.4)

       

         PERL_SITESEARCH    = path to the sitesearch install dir
         PERL_SITELIB       = path to the sitelib install directory
         PERL_VENDORARCH    = path to the vendor arch install directory
         PERL_VENDORLIB     = path to the vendor lib install directory
         PERL_ARCHLIB       = path to the arch lib install directory
         PERL_PRIVLIB       = path to the priv lib install directory
         PERL_EXTRA_C_FLAGS = Compilation flags used to build perl

       


  FindPhysFS
        

       Locate PhysFS library This module defines PHYSFS_LIBRARY, the name of
       the library to link against PHYSFS_FOUND, if false, do not try to link
       to PHYSFS PHYSFS_INCLUDE_DIR, where to find physfs.h

       $PHYSFSDIR is an environment variable that would correspond to the
       ./configure --prefix=$PHYSFSDIR used in building PHYSFS.

       Created by Eric Wing.

  FindPike
       Find Pike

       This module finds if PIKE is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PIKE_INCLUDE_PATH       = path to where program.h is found
         PIKE_EXECUTABLE         = full path to the pike binary

       


  FindPkgConfig
       a pkg-config module for CMake

       

       Usage:

          pkg_check_modules(<PREFIX> [REQUIRED] <MODULE> [<MODULE>]*)
            checks for all the given modules

       

          pkg_search_module(<PREFIX> [REQUIRED] <MODULE> [<MODULE>]*)
            checks for given modules and uses the first working one

       

       When the 'REQUIRED' argument was set, macros will fail with an error
       when module(s) could not be found

       It sets the following variables:

          PKG_CONFIG_FOUND         ... true if pkg-config works on the system
          PKG_CONFIG_EXECUTABLE    ... pathname of the pkg-config program
          <PREFIX>_FOUND           ... set to 1 if module(s) exist

       

       For the following variables two sets of values exist; first one is the
       common one and has the given PREFIX.  The second set contains flags
       which are given out when pkgconfig was called with the '--static'
       option.

          <XPREFIX>_LIBRARIES      ... only the libraries (w/o the '-l')
          <XPREFIX>_LIBRARY_DIRS   ... the paths of the libraries (w/o the '-L')
          <XPREFIX>_LDFLAGS        ... all required linker flags
          <XPREFIX>_LDFLAGS_OTHER  ... all other linker flags
          <XPREFIX>_INCLUDE_DIRS   ... the '-I' preprocessor flags (w/o the '-I')
          <XPREFIX>_CFLAGS         ... all required cflags
          <XPREFIX>_CFLAGS_OTHER   ... the other compiler flags

       

          <XPREFIX> = <PREFIX>        for common case
          <XPREFIX> = <PREFIX>_STATIC for static linking

       

       There are some special variables whose prefix depends on the count of
       given modules.  When there is only one module, <PREFIX> stays
       unchanged.  When there are multiple modules, the prefix will be
       changed to <PREFIX>_<MODNAME>:

          <XPREFIX>_VERSION    ... version of the module
          <XPREFIX>_PREFIX     ... prefix-directory of the module
          <XPREFIX>_INCLUDEDIR ... include-dir of the module
          <XPREFIX>_LIBDIR     ... lib-dir of the module

       

          <XPREFIX> = <PREFIX>  when |MODULES| == 1, else
          <XPREFIX> = <PREFIX>_<MODNAME>

       

       A <MODULE> parameter can have the following formats:

          {MODNAME}            ... matches any version
          {MODNAME}>={VERSION} ... at least version <VERSION> is required
          {MODNAME}={VERSION}  ... exactly version <VERSION> is required
          {MODNAME}<={VERSION} ... modules must not be newer than <VERSION>

       

       Examples

          pkg_check_modules (GLIB2   glib-2.0)

       

          pkg_check_modules (GLIB2   glib-2.0>=2.10)
            requires at least version 2.10 of glib2 and defines e.g.
              GLIB2_VERSION=2.10.3

       

          pkg_check_modules (FOO     glib-2.0>=2.10 gtk+-2.0)
            requires both glib2 and gtk2, and defines e.g.
              FOO_glib-2.0_VERSION=2.10.3
              FOO_gtk+-2.0_VERSION=2.8.20

       

          pkg_check_modules (XRENDER REQUIRED xrender)
            defines e.g.:
              XRENDER_LIBRARIES=Xrender;X11
              XRENDER_STATIC_LIBRARIES=Xrender;X11;pthread;Xau;Xdmcp

       

          pkg_search_module (BAR     libxml-2.0 libxml2 libxml>=2)


  FindProducer
        

       Though Producer isn't directly part of OpenSceneGraph, its primary
       user is OSG so I consider this part of the Findosg* suite used to find
       OpenSceneGraph components.  You'll notice that I accept OSGDIR as an
       environment path.

       Each component is separate and you must opt in to each module.  You
       must also opt into OpenGL (and OpenThreads?) as these modules won't do
       it for you.  This is to allow you control over your own system piece
       by piece in case you need to opt out of certain components or change
       the Find behavior for a particular module (perhaps because the default
       FindOpenGL.cmake module doesn't work with your system as an example).
       If you want to use a more convenient module that includes everything,
       use the FindOpenSceneGraph.cmake instead of the Findosg*.cmake
       modules.

       Locate Producer This module defines PRODUCER_LIBRARY PRODUCER_FOUND,
       if false, do not try to link to Producer PRODUCER_INCLUDE_DIR, where
       to find the headers

       $PRODUCER_DIR is an environment variable that would correspond to the
       ./configure --prefix=$PRODUCER_DIR used in building osg.

       Created by Eric Wing.

  FindProtobuf
        

       Locate and configure the Google Protocol Buffers library.  Defines the
       following variables:

          PROTOBUF_FOUND - Found the Google Protocol Buffers library
          PROTOBUF_INCLUDE_DIRS - Include directories for Google Protocol Buffers
          PROTOBUF_LIBRARIES - The protobuf library

       

       The following cache variables are also defined:

          PROTOBUF_LIBRARY - The protobuf library
          PROTOBUF_PROTOC_LIBRARY   - The protoc library
          PROTOBUF_INCLUDE_DIR - The include directory for protocol buffers
          PROTOBUF_PROTOC_EXECUTABLE - The protoc compiler

       

         ====================================================================
         Example:

       

          find_package(Protobuf REQUIRED)
          include_directories(${PROTOBUF_INCLUDE_DIRS})

       

          include_directories(${CMAKE_CURRENT_BINARY_DIR})
          PROTOBUF_GENERATE_CPP(PROTO_SRCS PROTO_HDRS foo.proto)
          add_executable(bar bar.cc ${PROTO_SRCS} ${PROTO_HDRS})
          target_link_libraries(bar ${PROTOBUF_LIBRARY})

       

       NOTE: You may need to link against pthreads, depending on the
       platform.

         ====================================================================

       

       PROTOBUF_GENERATE_CPP (public function)

          SRCS = Variable to define with autogenerated
                 source files
          HDRS = Variable to define with autogenerated
                 header files
          ARGN = proto files

       

         ====================================================================


  FindPythonInterp
       Find python interpreter

       This module finds if Python interpreter is installed and determines
       where the executables are.  This code sets the following variables:

         PYTHONINTERP_FOUND - Was the Python executable found
         PYTHON_EXECUTABLE  - path to the Python interpreter

       


  FindPythonLibs
       Find python libraries

       This module finds if Python is installed and determines where the
       include files and libraries are.  It also determines what the name of
       the library is.  This code sets the following variables:

         PYTHONLIBS_FOUND       - have the Python libs been found
         PYTHON_LIBRARIES       - path to the python library
         PYTHON_INCLUDE_PATH    - path to where Python.h is found (deprecated)
         PYTHON_INCLUDE_DIRS    - path to where Python.h is found
         PYTHON_DEBUG_LIBRARIES - path to the debug library

       


  FindQt
       Searches for all installed versions of QT.

       This should only be used if your project can work with multiple
       versions of QT.  If not, you should just directly use FindQt4 or
       FindQt3.  If multiple versions of QT are found on the machine, then
       The user must set the option DESIRED_QT_VERSION to the version they
       want to use.  If only one version of qt is found on the machine, then
       the DESIRED_QT_VERSION is set to that version and the matching FindQt3
       or FindQt4 module is included.  Once the user sets DESIRED_QT_VERSION,
       then the FindQt3 or FindQt4 module is included.

         QT_REQUIRED if this is set to TRUE then if CMake can 
                     not find QT4 or QT3 an error is raised 
                     and a message is sent to the user.

       

         DESIRED_QT_VERSION OPTION is created
         QT4_INSTALLED is set to TRUE if qt4 is found.
         QT3_INSTALLED is set to TRUE if qt3 is found.


  FindQt3
       Locate Qt include paths and libraries

       This module defines:

         QT_INCLUDE_DIR - where to find qt.h, etc.
         QT_LIBRARIES   - the libraries to link against to use Qt.
         QT_DEFINITIONS - definitions to use when
                          compiling code that uses Qt.
         QT_FOUND       - If false, don't try to use Qt.

       

       If you need the multithreaded version of Qt, set QT_MT_REQUIRED to
       TRUE

       Also defined, but not for general use are:

         QT_MOC_EXECUTABLE, where to find the moc tool.
         QT_UIC_EXECUTABLE, where to find the uic tool.
         QT_QT_LIBRARY, where to find the Qt library.
         QT_QTMAIN_LIBRARY, where to find the qtmain
          library. This is only required by Qt3 on Windows.


  FindQt4
       Find QT 4

       This module can be used to find Qt4.  The most important issue is that
       the Qt4 qmake is available via the system path.  This qmake is then
       used to detect basically everything else.  This module defines a
       number of key variables and macros.  The variable QT_USE_FILE is set
       which is the path to a CMake file that can be included to compile Qt 4
       applications and libraries.  It sets up the compilation environment
       for include directories, preprocessor defines and populates a
       QT_LIBRARIES variable.

       Typical usage could be something like:

          find_package(Qt4 4.4.3 COMPONENTS QtCore QtGui QtXml REQUIRED )
          include(${QT_USE_FILE})
          add_executable(myexe main.cpp)
          target_link_libraries(myexe ${QT_LIBRARIES})

       

       The minimum required version can be specified using the standard
       find_package()-syntax (see example above).  For compatibility with
       older versions of FindQt4.cmake it is also possible to set the
       variable QT_MIN_VERSION to the minimum required version of Qt4 before
       the find_package(Qt4) command.  If both are used, the version used in
       the find_package() command overrides the one from QT_MIN_VERSION.

       When using the components argument, QT_USE_QT* variables are
       automatically set for the QT_USE_FILE to pick up.  If one wishes to
       manually set them, the available ones to set include:

                           QT_DONT_USE_QTCORE
                           QT_DONT_USE_QTGUI
                           QT_USE_QT3SUPPORT
                           QT_USE_QTASSISTANT
                           QT_USE_QAXCONTAINER
                           QT_USE_QAXSERVER
                           QT_USE_QTDESIGNER
                           QT_USE_QTMOTIF
                           QT_USE_QTMAIN
                           QT_USE_QTNETWORK
                           QT_USE_QTNSPLUGIN
                           QT_USE_QTOPENGL
                           QT_USE_QTSQL
                           QT_USE_QTXML
                           QT_USE_QTSVG
                           QT_USE_QTTEST
                           QT_USE_QTUITOOLS
                           QT_USE_QTDBUS
                           QT_USE_QTSCRIPT
                           QT_USE_QTASSISTANTCLIENT
                           QT_USE_QTHELP
                           QT_USE_QTWEBKIT
                           QT_USE_QTXMLPATTERNS
                           QT_USE_PHONON
                           QT_USE_QTSCRIPTTOOLS

       

       There are also some files that need processing by some Qt tools such
       as moc and uic.  Listed below are macros that may be used to process
       those files.

         
         macro QT4_WRAP_CPP(outfiles inputfile ... OPTIONS ...)
               create moc code from a list of files containing Qt class with
               the Q_OBJECT declaration.  Per-direcotry preprocessor definitions 
               are also added.  Options may be given to moc, such as those found
               when executing "moc -help".  

       

         macro QT4_WRAP_UI(outfiles inputfile ... OPTIONS ...)
               create code from a list of Qt designer ui files.
               Options may be given to uic, such as those found
               when executing "uic -help"

       

         macro QT4_ADD_RESOURCES(outfiles inputfile ... OPTIONS ...)
               create code from a list of Qt resource files.
               Options may be given to rcc, such as those found
               when executing "rcc -help"

       

         macro QT4_GENERATE_MOC(inputfile outputfile )
               creates a rule to run moc on infile and create outfile.
               Use this if for some reason QT4_WRAP_CPP() isn't appropriate, e.g.
               because you need a custom filename for the moc file or something similar.

       

         macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
               This macro is still experimental.
               It can be used to have moc automatically handled.
               So if you have the files foo.h and foo.cpp, and in foo.h a 
               a class uses the Q_OBJECT macro, moc has to run on it. If you don't
               want to use QT4_WRAP_CPP() (which is reliable and mature), you can insert
               #include "foo.moc"
               in foo.cpp and then give foo.cpp as argument to QT4_AUTOMOC(). This will the
               scan all listed files at cmake-time for such included moc files and if it finds
               them cause a rule to be generated to run moc at build time on the 
               accompanying header file foo.h.
               If a source file has the SKIP_AUTOMOC property set it will be ignored by this macro.

       

         macro QT4_ADD_DBUS_INTERFACE(outfiles interface basename)
               create a the interface header and implementation files with the 
               given basename from the given interface xml file and add it to 
               the list of sources

       

         macro QT4_ADD_DBUS_INTERFACES(outfiles inputfile ... )
               create the interface header and implementation files 
               for all listed interface xml files
               the name will be automatically determined from the name of the xml file

       

         macro QT4_ADD_DBUS_ADAPTOR(outfiles xmlfile parentheader parentclassname [basename] [classname])
               create a dbus adaptor (header and implementation file) from the xml file
               describing the interface, and add it to the list of sources. The adaptor
               forwards the calls to a parent class, defined in parentheader and named
               parentclassname. The name of the generated files will be
               <basename>adaptor.{cpp,h} where basename defaults to the basename of the xml file.
               If <classname> is provided, then it will be used as the classname of the
               adaptor itself.

       

         macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] OPTIONS ...)
               generate the xml interface file from the given header.
               If the optional argument interfacename is omitted, the name of the 
               interface file is constructed from the basename of the header with
               the suffix .xml appended.
               Options may be given to qdbuscpp2xml, such as those found when executing "qdbuscpp2xml --help"

       

         macro QT4_CREATE_TRANSLATION( qm_files directories ... sources ... 
                                       ts_files ... OPTIONS ...)
               out: qm_files
               in:  directories sources ts_files
               options: flags to pass to lupdate, such as -extensions to specify
               extensions for a directory scan.
               generates commands to create .ts (vie lupdate) and .qm
               (via lrelease) - files from directories and/or sources. The ts files are 
               created and/or updated in the source tree (unless given with full paths).
               The qm files are generated in the build tree.
               Updating the translations can be done by adding the qm_files
               to the source list of your library/executable, so they are
               always updated, or by adding a custom target to control when
               they get updated/generated.

       

         macro QT4_ADD_TRANSLATION( qm_files ts_files ... )
               out: qm_files
               in:  ts_files
               generates commands to create .qm from .ts - files. The generated
               filenames can be found in qm_files. The ts_files
               must exists and are not updated in any way.

       

       

         Below is a detailed list of variables that FindQt4.cmake sets.
         QT_FOUND         If false, don't try to use Qt.
         QT4_FOUND        If false, don't try to use Qt 4.

       

         QT_VERSION_MAJOR The major version of Qt found.
         QT_VERSION_MINOR The minor version of Qt found.
         QT_VERSION_PATCH The patch version of Qt found.

       

         QT_EDITION               Set to the edition of Qt (i.e. DesktopLight)
         QT_EDITION_DESKTOPLIGHT  True if QT_EDITION == DesktopLight
         QT_QTCORE_FOUND          True if QtCore was found.
         QT_QTGUI_FOUND           True if QtGui was found.
         QT_QT3SUPPORT_FOUND      True if Qt3Support was found.
         QT_QTASSISTANT_FOUND     True if QtAssistant was found.
         QT_QAXCONTAINER_FOUND     True if QAxContainer was found (Windows only).
         QT_QAXSERVER_FOUND          True if QAxServer was found (Windows only).
         QT_QTDBUS_FOUND          True if QtDBus was found.
         QT_QTDESIGNER_FOUND      True if QtDesigner was found.
         QT_QTDESIGNERCOMPONENTS  True if QtDesignerComponents was found.
         QT_QTMOTIF_FOUND         True if QtMotif was found.
         QT_QTNETWORK_FOUND       True if QtNetwork was found.
         QT_QTNSPLUGIN_FOUND      True if QtNsPlugin was found.
         QT_QTOPENGL_FOUND        True if QtOpenGL was found.
         QT_QTSQL_FOUND           True if QtSql was found.
         QT_QTXML_FOUND           True if QtXml was found.
         QT_QTSVG_FOUND           True if QtSvg was found.
         QT_QTSCRIPT_FOUND        True if QtScript was found.
         QT_QTTEST_FOUND          True if QtTest was found.
         QT_QTUITOOLS_FOUND       True if QtUiTools was found.
         QT_QTASSISTANTCLIENT_FOUND  True if QtAssistantClient was found.
         QT_QTHELP_FOUND          True if QtHelp was found.
         QT_QTWEBKIT_FOUND        True if QtWebKit was found.
         QT_QTXMLPATTERNS_FOUND   True if QtXmlPatterns was found.
         QT_PHONON_FOUND          True if phonon was found.
         QT_QTSCRIPTTOOLS_FOUND   True if QtScriptTools was found.

       

         QT_MAC_USE_COCOA    For Mac OS X, its whether Cocoa or Carbon is used.
                             In general, this should not be used, but its useful
                             when having platform specific code.

       

         QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
                          You do not need to use this if you include QT_USE_FILE.
                          The QT_USE_FILE will also define QT_DEBUG and QT_NO_DEBUG
                          to fit your current build type.  Those are not contained
                          in QT_DEFINITIONS.
                         
         QT_INCLUDES      List of paths to all include directories of 
                          Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
                          always in this variable even if NOTFOUND,
                          all other INCLUDE_DIRS are
                          only added if they are found.
                          You do not need to use this if you include QT_USE_FILE.
          

       

         Include directories for the Qt modules are listed here.
         You do not need to use these variables if you include QT_USE_FILE.

       

         QT_INCLUDE_DIR              Path to "include" of Qt4
         QT_QT3SUPPORT_INCLUDE_DIR   Path to "include/Qt3Support" 
         QT_QTASSISTANT_INCLUDE_DIR  Path to "include/QtAssistant" 
         QT_QTASSISTANTCLIENT_INCLUDE_DIR       Path to "include/QtAssistant"
         QT_QAXCONTAINER_INCLUDE_DIR  Path to "include/ActiveQt" (Windows only)
         QT_QAXSERVER_INCLUDE_DIR  Path to "include/ActiveQt" (Windows only)
         QT_QTCORE_INCLUDE_DIR       Path to "include/QtCore"         
         QT_QTDESIGNER_INCLUDE_DIR   Path to "include/QtDesigner" 
         QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path to "include/QtDesigner"
         QT_QTDBUS_INCLUDE_DIR       Path to "include/QtDBus" 
         QT_QTGUI_INCLUDE_DIR        Path to "include/QtGui" 
         QT_QTHELP_INCLUDE_DIR       Path to "include/QtHelp"
         QT_QTMOTIF_INCLUDE_DIR      Path to "include/QtMotif" 
         QT_QTNETWORK_INCLUDE_DIR    Path to "include/QtNetwork" 
         QT_QTNSPLUGIN_INCLUDE_DIR   Path to "include/QtNsPlugin" 
         QT_QTOPENGL_INCLUDE_DIR     Path to "include/QtOpenGL" 
         QT_QTSCRIPT_INCLUDE_DIR     Path to "include/QtScript"
         QT_QTSQL_INCLUDE_DIR        Path to "include/QtSql" 
         QT_QTSVG_INCLUDE_DIR        Path to "include/QtSvg"
         QT_QTTEST_INCLUDE_DIR       Path to "include/QtTest"
         QT_QTWEBKIT_INCLUDE_DIR     Path to "include/QtWebKit"
         QT_QTXML_INCLUDE_DIR        Path to "include/QtXml" 
         QT_QTXMLPATTERNS_INCLUDE_DIR  Path to "include/QtXmlPatterns"
         QT_PHONON_INCLUDE_DIR       Path to "include/phonon"
         QT_QTSCRIPTTOOLS_INCLUDE_DIR       Path to "include/QtScriptTools"
                                   
         QT_BINARY_DIR               Path to "bin" of Qt4
         QT_LIBRARY_DIR              Path to "lib" of Qt4
         QT_PLUGINS_DIR              Path to "plugins" for Qt4
         QT_TRANSLATIONS_DIR         Path to "translations" of Qt4
         QT_DOC_DIR                  Path to "doc" of Qt4
         QT_MKSPECS_DIR              Path to "mkspecs" of Qt4
                                   

       

       The Qt toolkit may contain both debug and release libraries.  In that
       case, the following library variables will contain both.  You do not
       need to use these variables if you include QT_USE_FILE, and use
       QT_LIBRARIES.

         QT_QT3SUPPORT_LIBRARY            The Qt3Support library
         QT_QTASSISTANT_LIBRARY           The QtAssistant library
         QT_QTASSISTANTCLIENT_LIBRARY     The QtAssistantClient library
         QT_QAXCONTAINER_LIBRARY           The QAxContainer library (Windows only)
         QT_QAXSERVER_LIBRARY                The QAxServer library (Windows only)
         QT_QTCORE_LIBRARY                The QtCore library
         QT_QTDBUS_LIBRARY                The QtDBus library
         QT_QTDESIGNER_LIBRARY            The QtDesigner library
         QT_QTDESIGNERCOMPONENTS_LIBRARY  The QtDesignerComponents library
         QT_QTGUI_LIBRARY                 The QtGui library
         QT_QTHELP_LIBRARY                The QtHelp library
         QT_QTMOTIF_LIBRARY               The QtMotif library
         QT_QTNETWORK_LIBRARY             The QtNetwork library
         QT_QTNSPLUGIN_LIBRARY            The QtNsPLugin library
         QT_QTOPENGL_LIBRARY              The QtOpenGL library
         QT_QTSCRIPT_LIBRARY              The QtScript library
         QT_QTSQL_LIBRARY                 The QtSql library
         QT_QTSVG_LIBRARY                 The QtSvg library
         QT_QTTEST_LIBRARY                The QtTest library
         QT_QTUITOOLS_LIBRARY             The QtUiTools library
         QT_QTWEBKIT_LIBRARY              The QtWebKit library
         QT_QTXML_LIBRARY                 The QtXml library
         QT_QTXMLPATTERNS_LIBRARY         The QtXmlPatterns library
         QT_QTMAIN_LIBRARY                The qtmain library for Windows
         QT_PHONON_LIBRARY                The phonon library
         QT_QTSCRIPTTOOLS_LIBRARY         The QtScriptTools library
         

       also defined, but NOT for general use are

         QT_MOC_EXECUTABLE                   Where to find the moc tool.
         QT_UIC_EXECUTABLE                   Where to find the uic tool.
         QT_UIC3_EXECUTABLE                  Where to find the uic3 tool.
         QT_RCC_EXECUTABLE                   Where to find the rcc tool
         QT_DBUSCPP2XML_EXECUTABLE           Where to find the qdbuscpp2xml tool.
         QT_DBUSXML2CPP_EXECUTABLE           Where to find the qdbusxml2cpp tool.
         QT_LUPDATE_EXECUTABLE               Where to find the lupdate tool.
         QT_LRELEASE_EXECUTABLE              Where to find the lrelease tool.
         QT_QCOLLECTIONGENERATOR_EXECUTABLE  Where to find the qcollectiongenerator tool.
         

       

       These are around for backwards compatibility they will be set

         QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
         QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
         

       These variables do _NOT_ have any effect anymore (compared to
       FindQt.cmake)

         QT_MT_REQUIRED         Qt4 is now always multithreaded
         

       These variables are set to "" Because Qt structure changed (They make
       no sense in Qt4)

         QT_QT_LIBRARY        Qt-Library is now split


  FindQuickTime
        

       Locate QuickTime This module defines QUICKTIME_LIBRARY
       QUICKTIME_FOUND, if false, do not try to link to gdal
       QUICKTIME_INCLUDE_DIR, where to find the headers

       $QUICKTIME_DIR is an environment variable that would correspond to the
       ./configure --prefix=$QUICKTIME_DIR

       Created by Eric Wing.

  FindRTI
       Try to find M&S HLA RTI libraries

       This module finds if any HLA RTI is installed and locates the standard
       RTI include files and libraries.

       RTI is a simulation infrastructure standardized by IEEE and SISO.  It
       has a well defined C++ API that assures that simulation applications
       are independent on a particular RTI implementation.

         http://en.wikipedia.org/wiki/Run-Time_Infrastructure_(simulation)

       

       This code sets the following variables:

         RTI_INCLUDE_DIR = the directory where RTI includes file are found
         RTI_LIBRARIES = The libraries to link against to use RTI
         RTI_DEFINITIONS = -DRTI_USES_STD_FSTREAM
         RTI_FOUND = Set to FALSE if any HLA RTI was not found

       

       Report problems to <certi-devel@nongnu.org>

  FindRuby
       Find Ruby

       This module finds if Ruby is installed and determines where the
       include files and libraries are.  Ruby 1.8 and 1.9 are supported.  The
       minimum required version specified in the find_package() command is
       honored.  It also determines what the name of the library is.  This
       code sets the following variables:

         RUBY_EXECUTABLE   = full path to the ruby binary
         RUBY_INCLUDE_DIRS = include dirs to be used when using the ruby library
         RUBY_LIBRARY      = full path to the ruby library
         RUBY_VERSION      = the version of ruby which was found, e.g. "1.8.7"
         RUBY_FOUND        = set to true if ruby ws found successfully

       

         RUBY_INCLUDE_PATH = same as RUBY_INCLUDE_DIRS, only provided for compatibility reasons, don't use it


  FindSDL
        

       Locate SDL library This module defines SDL_LIBRARY, the name of the
       library to link against SDL_FOUND, if false, do not try to link to SDL
       SDL_INCLUDE_DIR, where to find SDL.h

       This module responds to the the flag: SDL_BUILDING_LIBRARY If this is
       defined, then no SDL_main will be linked in because only applications
       need main().  Otherwise, it is assumed you are building an application
       and this module will attempt to locate and set the the proper link
       flags as part of the returned SDL_LIBRARY variable.

       Don't forget to include SDLmain.h and SDLmain.m your project for the
       OS X framework based version.  (Other versions link to -lSDLmain which
       this module will try to find on your behalf.) Also for OS X, this
       module will automatically add the -framework Cocoa on your behalf.

       

       Additional Note: If you see an empty SDL_LIBRARY_TEMP in your
       configuration and no SDL_LIBRARY, it means CMake did not find your SDL
       library (SDL.dll, libsdl.so, SDL.framework, etc).  Set
       SDL_LIBRARY_TEMP to point to your SDL library, and configure again.
       Similarly, if you see an empty SDLMAIN_LIBRARY, you should set this
       value as appropriate.  These values are used to generate the final
       SDL_LIBRARY variable, but when these values are unset, SDL_LIBRARY
       does not get created.

       

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.  l.e.galup 9-20-02

       Modified by Eric Wing.  Added code to assist with automated building
       by using environmental variables and providing a more
       controlled/consistent search behavior.  Added new modifications to
       recognize OS X frameworks and additional Unix paths (FreeBSD, etc).
       Also corrected the header search path to follow "proper" SDL
       guidelines.  Added a search for SDLmain which is needed by some
       platforms.  Added a search for threads which is needed by some
       platforms.  Added needed compile switches for MinGW.

       On OSX, this will prefer the Framework version (if found) over others.
       People will have to manually change the cache values of SDL_LIBRARY to
       override this selection or set the CMake environment
       CMAKE_INCLUDE_PATH to modify the search paths.

       Note that the header path has changed from SDL/SDL.h to just SDL.h
       This needed to change because "proper" SDL convention is #include
       "SDL.h", not <SDL/SDL.h>.  This is done for portability reasons
       because not all systems place things in SDL/ (see FreeBSD).

  FindSDL_image
        

       Locate SDL_image library This module defines SDLIMAGE_LIBRARY, the
       name of the library to link against SDLIMAGE_FOUND, if false, do not
       try to link to SDL SDLIMAGE_INCLUDE_DIR, where to find SDL/SDL.h

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).

  FindSDL_mixer
        

       Locate SDL_mixer library This module defines SDLMIXER_LIBRARY, the
       name of the library to link against SDLMIXER_FOUND, if false, do not
       try to link to SDL SDLMIXER_INCLUDE_DIR, where to find SDL/SDL.h

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).

  FindSDL_net
        

       Locate SDL_net library This module defines SDLNET_LIBRARY, the name of
       the library to link against SDLNET_FOUND, if false, do not try to link
       against SDLNET_INCLUDE_DIR, where to find the headers

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).

  FindSDL_sound
        

       Locates the SDL_sound library

  FindSDL_ttf
        

       Locate SDL_ttf library This module defines SDLTTF_LIBRARY, the name of
       the library to link against SDLTTF_FOUND, if false, do not try to link
       to SDL SDLTTF_INCLUDE_DIR, where to find SDL/SDL.h

       $SDLDIR is an environment variable that would correspond to the
       ./configure --prefix=$SDLDIR used in building SDL.

       Created by Eric Wing.  This was influenced by the FindSDL.cmake
       module, but with modifications to recognize OS X frameworks and
       additional Unix paths (FreeBSD, etc).

  FindSWIG
       Find SWIG

       This module finds an installed SWIG.  It sets the following variables:

         SWIG_FOUND - set to true if SWIG is found
         SWIG_DIR - the directory where swig is installed
         SWIG_EXECUTABLE - the path to the swig executable
         SWIG_VERSION   - the version number of the swig executable

       

       All informations are collected from the SWIG_EXECUTABLE so the version
       to be found can be changed from the command line by means of setting
       SWIG_EXECUTABLE


  FindSelfPackers
       Find upx

       This module looks for some executable packers (i.e.  softwares that
       compress executables or shared libs into on-the-fly self-extracting
       executables or shared libs.  Examples:

         UPX: http://wildsau.idv.uni-linz.ac.at/mfx/upx.html


  FindSquish
       -- Typical Use

       

       This module can be used to find Squish (currently support is aimed at
       version 3).

         SQUISH_FOUND                    If false, don't try to use Squish
         SQUISH_VERSION_MAJOR            The major version of Squish found
         SQUISH_VERSION_MINOR            The minor version of Squish found
         SQUISH_VERSION_PATCH            The patch version of Squish found

       

         SQUISH_INSTALL_DIR              The Squish installation directory (containing bin, lib, etc)
         SQUISH_SERVER_EXECUTABLE        The squishserver executable
         SQUISH_CLIENT_EXECUTABLE        The squishrunner executable

       

         SQUISH_INSTALL_DIR_FOUND        Was the install directory found?
         SQUISH_SERVER_EXECUTABLE_FOUND  Was the server executable found?
         SQUISH_CLIENT_EXECUTABLE_FOUND  Was the client executable found?

       

       macro SQUISH_ADD_TEST(testName applicationUnderTest testSuite
       testCase)

         ENABLE_TESTING()
         FIND_PACKAGE(Squish)
         IF (SQUISH_FOUND)
           SQUISH_ADD_TEST(myTestName myApplication testSuiteName testCaseName)
         ENDIF (SQUISH_FOUND)

       


  FindSubversion
       Extract information from a subversion working copy

       The module defines the following variables:

         Subversion_SVN_EXECUTABLE - path to svn command line client
         Subversion_VERSION_SVN - version of svn command line client
         Subversion_FOUND - true if the command line client was found

       If the command line client executable is found the macro

         Subversion_WC_INFO(<dir> <var-prefix>)

       is defined to extract information of a subversion working copy at a
       given location.  The macro defines the following variables:

         <var-prefix>_WC_URL - url of the repository (at <dir>)
         <var-prefix>_WC_ROOT - root url of the repository
         <var-prefix>_WC_REVISION - current revision
         <var-prefix>_WC_LAST_CHANGED_AUTHOR - author of last commit
         <var-prefix>_WC_LAST_CHANGED_DATE - date of last commit
         <var-prefix>_WC_LAST_CHANGED_REV - revision of last commit
         <var-prefix>_WC_LAST_CHANGED_LOG - last log of base revision
         <var-prefix>_WC_INFO - output of command `svn info <dir>'

       Example usage:

         FIND_PACKAGE(Subversion)
         IF(Subversion_FOUND)
           Subversion_WC_INFO(${PROJECT_SOURCE_DIR} Project)
           MESSAGE("Current revision is ${Project_WC_REVISION}")
           Subversion_WC_LOG(${PROJECT_SOURCE_DIR} Project)
           MESSAGE("Last changed log is ${Project_LAST_CHANGED_LOG}")
         ENDIF(Subversion_FOUND)


  FindTCL
       TK_INTERNAL_PATH was removed.

       This module finds if Tcl is installed and determines where the include
       files and libraries are.  It also determines what the name of the
       library is.  This code sets the following variables:

         TCL_FOUND              = Tcl was found
         TK_FOUND               = Tk was found
         TCLTK_FOUND            = Tcl and Tk were found
         TCL_LIBRARY            = path to Tcl library (tcl tcl80)
         TCL_INCLUDE_PATH       = path to where tcl.h can be found
         TCL_TCLSH              = path to tclsh binary (tcl tcl80)
         TK_LIBRARY             = path to Tk library (tk tk80 etc)
         TK_INCLUDE_PATH        = path to where tk.h can be found
         TK_WISH                = full path to the wish executable

       

       In an effort to remove some clutter and clear up some issues for
       people who are not necessarily Tcl/Tk gurus/developpers, some
       variables were moved or removed.  Changes compared to CMake 2.4 are:

          => they were only useful for people writing Tcl/Tk extensions.
          => these libs are not packaged by default with Tcl/Tk distributions. 
             Even when Tcl/Tk is built from source, several flavors of debug libs
             are created and there is no real reason to pick a single one
             specifically (say, amongst tcl84g, tcl84gs, or tcl84sgx). 
             Let's leave that choice to the user by allowing him to assign 
             TCL_LIBRARY to any Tcl library, debug or not.
          => this ended up being only a Win32 variable, and there is a lot of
             confusion regarding the location of this file in an installed Tcl/Tk
             tree anyway (see 8.5 for example). If you need the internal path at
             this point it is safer you ask directly where the *source* tree is
             and dig from there.


  FindTIFF
       Find TIFF library

       Find the native TIFF includes and library This module defines

         TIFF_INCLUDE_DIR, where to find tiff.h, etc.
         TIFF_LIBRARIES, libraries to link against to use TIFF.
         TIFF_FOUND, If false, do not try to use TIFF.

       also defined, but not for general use are

         TIFF_LIBRARY, where to find the TIFF library.


  FindTclStub
       TCL_STUB_LIBRARY_DEBUG and TK_STUB_LIBRARY_DEBUG were removed.

       This module finds Tcl stub libraries.  It first finds Tcl include
       files and libraries by calling FindTCL.cmake.  How to Use the Tcl
       Stubs Library:

          http://tcl.activestate.com/doc/howto/stubs.html

       Using Stub Libraries:

          http://safari.oreilly.com/0130385603/ch48lev1sec3

       This code sets the following variables:

         TCL_STUB_LIBRARY       = path to Tcl stub library
         TK_STUB_LIBRARY        = path to Tk stub library
         TTK_STUB_LIBRARY       = path to ttk stub library

       

       In an effort to remove some clutter and clear up some issues for
       people who are not necessarily Tcl/Tk gurus/developpers, some
       variables were moved or removed.  Changes compared to CMake 2.4 are:

          => these libs are not packaged by default with Tcl/Tk distributions. 
             Even when Tcl/Tk is built from source, several flavors of debug libs
             are created and there is no real reason to pick a single one
             specifically (say, amongst tclstub84g, tclstub84gs, or tclstub84sgx). 
             Let's leave that choice to the user by allowing him to assign 
             TCL_STUB_LIBRARY to any Tcl library, debug or not.


  FindTclsh
       Find tclsh

       This module finds if TCL is installed and determines where the include
       files and libraries are.  It also determines what the name of the
       library is.  This code sets the following variables:

         TCLSH_FOUND = TRUE if tclsh has been found
         TCL_TCLSH = the path to the tclsh executable

       In cygwin, look for the cygwin version first.  Don't look for it later
       to avoid finding the cygwin version on a Win32 build.

  FindThreads
       This module determines the thread library of the system.

       The following variables are set

         CMAKE_THREAD_LIBS_INIT     - the thread library
         CMAKE_USE_SPROC_INIT       - are we using sproc?
         CMAKE_USE_WIN32_THREADS_INIT - using WIN32 threads?
         CMAKE_USE_PTHREADS_INIT    - are we using pthreads
         CMAKE_HP_PTHREADS_INIT     - are we using hp pthreads


  FindUnixCommands
       Find unix commands from cygwin

       This module looks for some usual Unix commands.


  FindVTK
       Find a VTK installation or build tree.

       The following variables are set if VTK is found.  If VTK is not found,
       VTK_FOUND is set to false.

         VTK_FOUND         - Set to true when VTK is found.
         VTK_USE_FILE      - CMake file to use VTK.
         VTK_MAJOR_VERSION - The VTK major version number.
         VTK_MINOR_VERSION - The VTK minor version number 
                              (odd non-release).
         VTK_BUILD_VERSION - The VTK patch level 
                              (meaningless for odd minor).
         VTK_INCLUDE_DIRS  - Include directories for VTK
         VTK_LIBRARY_DIRS  - Link directories for VTK libraries
         VTK_KITS          - List of VTK kits, in CAPS 
                             (COMMON,IO,) etc.
         VTK_LANGUAGES     - List of wrapped languages, in CAPS
                             (TCL, PYHTON,) etc.

       The following cache entries must be set by the user to locate VTK:

         VTK_DIR  - The directory containing VTKConfig.cmake.  
                    This is either the root of the build tree,
                    or the lib/vtk directory.  This is the 
                    only cache entry.

       The following variables are set for backward compatibility and should
       not be used in new code:

         USE_VTK_FILE - The full path to the UseVTK.cmake file.
                        This is provided for backward 
                        compatibility.  Use VTK_USE_FILE 
                        instead.

       


  FindWget
       Find wget

       This module looks for wget.  This module defines the following values:

         WGET_EXECUTABLE: the full path to the wget tool.
         WGET_FOUND: True if wget has been found.


  FindWish
       Find wish installation

       This module finds if TCL is installed and determines where the include
       files and libraries are.  It also determines what the name of the
       library is.  This code sets the following variables:

         TK_WISH = the path to the wish executable

       

       if UNIX is defined, then it will look for the cygwin version first

  FindX11
       Find X11 installation

       Try to find X11 on UNIX systems.  The following values are defined

         X11_FOUND        - True if X11 is available
         X11_INCLUDE_DIR  - include directories to use X11
         X11_LIBRARIES    - link against these to use X11

       

       and also the following more fine grained variables: Include paths:
       X11_ICE_INCLUDE_PATH, X11_ICE_LIB, X11_ICE_FOUND

                       X11_Xaccessrules_INCLUDE_PATH,                     X11_Xaccess_FOUND
                       X11_Xaccessstr_INCLUDE_PATH,                       X11_Xaccess_FOUND
                       X11_Xau_INCLUDE_PATH,          X11_Xau_LIB,        X11_Xau_FOUND
                       X11_Xcomposite_INCLUDE_PATH,   X11_Xcomposite_LIB, X11_Xcomposite_FOUND
                       X11_Xcursor_INCLUDE_PATH,      X11_Xcursor_LIB,    X11_Xcursor_FOUND
                       X11_Xdamage_INCLUDE_PATH,      X11_Xdamage_LIB,    X11_Xdamage_FOUND
                       X11_Xdmcp_INCLUDE_PATH,        X11_Xdmcp_LIB,      X11_Xdmcp_FOUND
                                                      X11_Xext_LIB,       X11_Xext_FOUND
                       X11_dpms_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_dpms_FOUND
                       X11_XShm_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_XShm_FOUND
                       X11_Xshape_INCLUDE_PATH,       (in X11_Xext_LIB),  X11_Xshape_FOUND
                       X11_xf86misc_INCLUDE_PATH,     X11_Xxf86misc_LIB,  X11_xf86misc_FOUND
                       X11_xf86vmode_INCLUDE_PATH,                        X11_xf86vmode_FOUND
                       X11_Xfixes_INCLUDE_PATH,       X11_Xfixes_LIB,     X11_Xfixes_FOUND
                       X11_Xft_INCLUDE_PATH,          X11_Xft_LIB,        X11_Xft_FOUND
                       X11_Xinerama_INCLUDE_PATH,     X11_Xinerama_LIB,   X11_Xinerama_FOUND
                       X11_Xinput_INCLUDE_PATH,       X11_Xinput_LIB,     X11_Xinput_FOUND
                       X11_Xkb_INCLUDE_PATH,                              X11_Xkb_FOUND
                       X11_Xkblib_INCLUDE_PATH,                           X11_Xkb_FOUND
                       X11_Xpm_INCLUDE_PATH,          X11_Xpm_LIB,        X11_Xpm_FOUND
                       X11_XTest_INCLUDE_PATH,        X11_XTest_LIB,      X11_XTest_FOUND
                       X11_Xrandr_INCLUDE_PATH,       X11_Xrandr_LIB,     X11_Xrandr_FOUND
                       X11_Xrender_INCLUDE_PATH,      X11_Xrender_LIB,    X11_Xrender_FOUND
                       X11_Xscreensaver_INCLUDE_PATH, X11_Xscreensaver_LIB, X11_Xscreensaver_FOUND
                       X11_Xt_INCLUDE_PATH,           X11_Xt_LIB,         X11_Xt_FOUND
                       X11_Xutil_INCLUDE_PATH,                            X11_Xutil_FOUND
                       X11_Xv_INCLUDE_PATH,           X11_Xv_LIB,         X11_Xv_FOUND


  FindXMLRPC
       Find xmlrpc

       Find the native XMLRPC headers and libraries.

         XMLRPC_INCLUDE_DIRS      - where to find xmlrpc.h, etc.
         XMLRPC_LIBRARIES         - List of libraries when using xmlrpc.
         XMLRPC_FOUND             - True if xmlrpc found.

       XMLRPC modules may be specified as components for this find module.
       Modules may be listed by running "xmlrpc-c-config".  Modules include:

         c++            C++ wrapper code
         libwww-client  libwww-based client
         cgi-server     CGI-based server
         abyss-server   ABYSS-based server

       Typical usage:

         FIND_PACKAGE(XMLRPC REQUIRED libwww-client)


  FindZLIB
       Find zlib

       Find the native ZLIB includes and library

         ZLIB_INCLUDE_DIRS - where to find zlib.h, etc.
         ZLIB_LIBRARIES    - List of libraries when using zlib.
         ZLIB_FOUND        - True if zlib found.


  Findosg
        

       

       NOTE: It is highly recommended that you use the new
       FindOpenSceneGraph.cmake introduced in CMake 2.6.3 and not use this
       Find module directly.

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osg This module defines

       OSG_FOUND - Was the Osg found? OSG_INCLUDE_DIR - Where to find the
       headers OSG_LIBRARIES - The libraries to link against for the OSG (use
       this)

       OSG_LIBRARY - The OSG library OSG_LIBRARY_DEBUG - The OSG debug
       library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgAnimation
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgAnimation This module defines

       OSGANIMATION_FOUND - Was osgAnimation found? OSGANIMATION_INCLUDE_DIR
       - Where to find the headers OSGANIMATION_LIBRARIES - The libraries to
       link against for the OSG (use this)

       OSGANIMATION_LIBRARY - The OSG library OSGANIMATION_LIBRARY_DEBUG -
       The OSG debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgDB
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgDB This module defines

       OSGDB_FOUND - Was osgDB found? OSGDB_INCLUDE_DIR - Where to find the
       headers OSGDB_LIBRARIES - The libraries to link against for the osgDB
       (use this)

       OSGDB_LIBRARY - The osgDB library OSGDB_LIBRARY_DEBUG - The osgDB
       debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgFX
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgFX This module defines

       OSGFX_FOUND - Was osgFX found? OSGFX_INCLUDE_DIR - Where to find the
       headers OSGFX_LIBRARIES - The libraries to link against for the osgFX
       (use this)

       OSGFX_LIBRARY - The osgFX library OSGFX_LIBRARY_DEBUG - The osgFX
       debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgGA
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgGA This module defines

       OSGGA_FOUND - Was osgGA found? OSGGA_INCLUDE_DIR - Where to find the
       headers OSGGA_LIBRARIES - The libraries to link against for the osgGA
       (use this)

       OSGGA_LIBRARY - The osgGA library OSGGA_LIBRARY_DEBUG - The osgGA
       debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgIntrospection
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgINTROSPECTION This module defines

       OSGINTROSPECTION_FOUND - Was osgIntrospection found?
       OSGINTROSPECTION_INCLUDE_DIR - Where to find the headers
       OSGINTROSPECTION_LIBRARIES - The libraries to link for
       osgIntrospection (use this)

       OSGINTROSPECTION_LIBRARY - The osgIntrospection library
       OSGINTROSPECTION_LIBRARY_DEBUG - The osgIntrospection debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgManipulator
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgManipulator This module defines

       OSGMANIPULATOR_FOUND - Was osgManipulator found?
       OSGMANIPULATOR_INCLUDE_DIR - Where to find the headers
       OSGMANIPULATOR_LIBRARIES - The libraries to link for osgManipulator
       (use this)

       OSGMANIPULATOR_LIBRARY - The osgManipulator library
       OSGMANIPULATOR_LIBRARY_DEBUG - The osgManipulator debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgParticle
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgParticle This module defines

       OSGPARTICLE_FOUND - Was osgParticle found? OSGPARTICLE_INCLUDE_DIR -
       Where to find the headers OSGPARTICLE_LIBRARIES - The libraries to
       link for osgParticle (use this)

       OSGPARTICLE_LIBRARY - The osgParticle library
       OSGPARTICLE_LIBRARY_DEBUG - The osgParticle debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgProducer
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgProducer This module defines

       OSGPRODUCER_FOUND - Was osgProducer found? OSGPRODUCER_INCLUDE_DIR -
       Where to find the headers OSGPRODUCER_LIBRARIES - The libraries to
       link for osgProducer (use this)

       OSGPRODUCER_LIBRARY - The osgProducer library
       OSGPRODUCER_LIBRARY_DEBUG - The osgProducer debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgShadow
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgShadow This module defines

       OSGSHADOW_FOUND - Was osgShadow found? OSGSHADOW_INCLUDE_DIR - Where
       to find the headers OSGSHADOW_LIBRARIES - The libraries to link for
       osgShadow (use this)

       OSGSHADOW_LIBRARY - The osgShadow library OSGSHADOW_LIBRARY_DEBUG -
       The osgShadow debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgSim
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgSim This module defines

       OSGSIM_FOUND - Was osgSim found? OSGSIM_INCLUDE_DIR - Where to find
       the headers OSGSIM_LIBRARIES - The libraries to link for osgSim (use
       this)

       OSGSIM_LIBRARY - The osgSim library OSGSIM_LIBRARY_DEBUG - The osgSim
       debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgTerrain
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgTerrain This module defines

       OSGTERRAIN_FOUND - Was osgTerrain found? OSGTERRAIN_INCLUDE_DIR -
       Where to find the headers OSGTERRAIN_LIBRARIES - The libraries to link
       for osgTerrain (use this)

       OSGTERRAIN_LIBRARY - The osgTerrain library OSGTERRAIN_LIBRARY_DEBUG -
       The osgTerrain debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgText
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgText This module defines

       OSGTEXT_FOUND - Was osgText found? OSGTEXT_INCLUDE_DIR - Where to find
       the headers OSGTEXT_LIBRARIES - The libraries to link for osgText (use
       this)

       OSGTEXT_LIBRARY - The osgText library OSGTEXT_LIBRARY_DEBUG - The
       osgText debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgUtil
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgUtil This module defines

       OSGUTIL_FOUND - Was osgUtil found? OSGUTIL_INCLUDE_DIR - Where to find
       the headers OSGUTIL_LIBRARIES - The libraries to link for osgUtil (use
       this)

       OSGUTIL_LIBRARY - The osgUtil library OSGUTIL_LIBRARY_DEBUG - The
       osgUtil debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgViewer
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgViewer This module defines

       OSGVIEWER_FOUND - Was osgViewer found? OSGVIEWER_INCLUDE_DIR - Where
       to find the headers OSGVIEWER_LIBRARIES - The libraries to link for
       osgViewer (use this)

       OSGVIEWER_LIBRARY - The osgViewer library OSGVIEWER_LIBRARY_DEBUG -
       The osgViewer debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgVolume
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgVolume This module defines

       OSGVOLUME_FOUND - Was osgVolume found? OSGVOLUME_INCLUDE_DIR - Where
       to find the headers OSGVOLUME_LIBRARIES - The libraries to link for
       osgVolume (use this)

       OSGVOLUME_LIBRARY - The osgVolume library OSGVOLUME_LIBRARY_DEBUG -
       The osgVolume debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       Created by Eric Wing.

  FindosgWidget
        

       This is part of the Findosg* suite used to find OpenSceneGraph
       components.  Each component is separate and you must opt in to each
       module.  You must also opt into OpenGL and OpenThreads (and Producer
       if needed) as these modules won't do it for you.  This is to allow you
       control over your own system piece by piece in case you need to opt
       out of certain components or change the Find behavior for a particular
       module (perhaps because the default FindOpenGL.cmake module doesn't
       work with your system as an example).  If you want to use a more
       convenient module that includes everything, use the
       FindOpenSceneGraph.cmake instead of the Findosg*.cmake modules.

       Locate osgWidget This module defines

       OSGWIDGET_FOUND - Was osgWidget found? OSGWIDGET_INCLUDE_DIR - Where
       to find the headers OSGWIDGET_LIBRARIES - The libraries to link for
       osgWidget (use this)

       OSGWIDGET_LIBRARY - The osgWidget library OSGWIDGET_LIBRARY_DEBUG -
       The osgWidget debug library

       $OSGDIR is an environment variable that would correspond to the
       ./configure --prefix=$OSGDIR used in building osg.

       FindosgWidget.cmake tweaked from Findosg* suite as created by Eric
       Wing.

  Findosg_functions
        

       

       This CMake file contains two macros to assist with searching for OSG
       libraries and nodekits.


  FindwxWidgets
       Find a wxWidgets (a.k.a., wxWindows) installation.

       This module finds if wxWidgets is installed and selects a default
       configuration to use.  wxWidgets is a modular library.  To specify the
       modules that you will use, you need to name them as components to the
       package:

       FIND_PACKAGE(wxWidgets COMPONENTS base core ...)

       There are two search branches: a windows style and a unix style.  For
       windows, the following variables are searched for and set to defaults
       in case of multiple choices.  Change them if the defaults are not
       desired (i.e., these are the only variables you should change to
       select a configuration):

         wxWidgets_ROOT_DIR      - Base wxWidgets directory
                                   (e.g., C:/wxWidgets-2.6.3).
         wxWidgets_LIB_DIR       - Path to wxWidgets libraries
                                   (e.g., C:/wxWidgets-2.6.3/lib/vc_lib).
         wxWidgets_CONFIGURATION - Configuration to use
                                   (e.g., msw, mswd, mswu, mswunivud, etc.)

       

       For unix style it uses the wx-config utility.  You can select between
       debug/release, unicode/ansi, universal/non-universal, and
       static/shared in the QtDialog or ccmake interfaces by turning ON/OFF
       the following variables:

         wxWidgets_USE_DEBUG
         wxWidgets_USE_UNICODE
         wxWidgets_USE_UNIVERSAL
         wxWidgets_USE_STATIC
         

       The following are set after the configuration is done for both windows
       and unix style:

         wxWidgets_FOUND            - Set to TRUE if wxWidgets was found.
         wxWidgets_INCLUDE_DIRS     - Include directories for WIN32
                                      i.e., where to find "wx/wx.h" and
                                      "wx/setup.h"; possibly empty for unices.
         wxWidgets_LIBRARIES        - Path to the wxWidgets libraries.
         wxWidgets_LIBRARY_DIRS     - compile time link dirs, useful for
                                      rpath on UNIX. Typically an empty string
                                      in WIN32 environment.
         wxWidgets_DEFINITIONS      - Contains defines required to compile/link
                                      against WX, e.g. WXUSINGDLL
         wxWidgets_DEFINITIONS_DEBUG- Contains defines required to compile/link
                                      against WX debug builds, e.g. __WXDEBUG__
         wxWidgets_CXX_FLAGS        - Include dirs and compiler flags for
                                      unices, empty on WIN32. Essentially
                                      "`wx-config --cxxflags`".
         wxWidgets_USE_FILE         - Convenience include file.

       

       Sample usage:

          FIND_PACKAGE(wxWidgets COMPONENTS base core gl net)
          IF(wxWidgets_FOUND)
            INCLUDE(${wxWidgets_USE_FILE})
            # and for each of your dependant executable/library targets:
            TARGET_LINK_LIBRARIES(<YourTarget> ${wxWidgets_LIBRARIES})
          ENDIF(wxWidgets_FOUND)

       

       If wxWidgets is required (i.e., not an optional part):

          FIND_PACKAGE(wxWidgets REQUIRED base core gl net)
          INCLUDE(${wxWidgets_USE_FILE})
          # and for each of your dependant executable/library targets:
          TARGET_LINK_LIBRARIES(<YourTarget> ${wxWidgets_LIBRARIES})


  FindwxWindows
       Find wxWindows (wxWidgets) installation

       This module finds if wxWindows/wxWidgets is installed and determines
       where the include files and libraries are.  It also determines what
       the name of the library is.  Please note this file is DEPRECATED and
       replaced by FindwxWidgets.cmake.  This code sets the following
       variables:

         WXWINDOWS_FOUND     = system has WxWindows
         WXWINDOWS_LIBRARIES = path to the wxWindows libraries
                               on Unix/Linux with additional
                               linker flags from
                               "wx-config --libs"
         CMAKE_WXWINDOWS_CXX_FLAGS  = Compiler flags for wxWindows,
                                      essentially "`wx-config --cxxflags`"
                                      on Linux
         WXWINDOWS_INCLUDE_DIR      = where to find "wx/wx.h" and "wx/setup.h"
         WXWINDOWS_LINK_DIRECTORIES = link directories, useful for rpath on
                                       Unix
         WXWINDOWS_DEFINITIONS      = extra defines

       

       OPTIONS If you need OpenGL support please

         SET(WXWINDOWS_USE_GL 1)

       in your CMakeLists.txt *before* you include this file.

         HAVE_ISYSTEM      - true required to replace -I by -isystem on g++

       

       For convenience include Use_wxWindows.cmake in your project's
       CMakeLists.txt using INCLUDE(Use_wxWindows).

       USAGE

         SET(WXWINDOWS_USE_GL 1)
         FIND_PACKAGE(wxWindows)

       

       NOTES wxWidgets 2.6.x is supported for monolithic builds e.g.
       compiled in wx/build/msw dir as:

         nmake -f makefile.vc BUILD=debug SHARED=0 USE_OPENGL=1 MONOLITHIC=1

       

       DEPRECATED

         CMAKE_WX_CAN_COMPILE
         WXWINDOWS_LIBRARY
         CMAKE_WX_CXX_FLAGS
         WXWINDOWS_INCLUDE_PATH

       

       AUTHOR Jan Woetzel <http://www.mip.informatik.uni-kiel.de/~jw>
       (07/2003-01/2006)

  FortranCInterface
       Fortran/C Interface Detection

       This module automatically detects the API by which C and Fortran
       languages interact.  Variables indicate if the mangling is found:

          FortranCInterface_GLOBAL_FOUND = Global subroutines and functions
          FortranCInterface_MODULE_FOUND = Module subroutines and functions
                                           (declared by "MODULE PROCEDURE")

       A function is provided to generate a C header file containing macros
       to mangle symbol names:

          FortranCInterface_HEADER(<file>
                                   [MACRO_NAMESPACE <macro-ns>]
                                   [SYMBOL_NAMESPACE <ns>]
                                   [SYMBOLS [<module>:]<function> ...])

       It generates in <file> definitions of the following macros:

          #define FortranCInterface_GLOBAL (name,NAME) ...
          #define FortranCInterface_GLOBAL_(name,NAME) ...
          #define FortranCInterface_MODULE (mod,name, MOD,NAME) ...
          #define FortranCInterface_MODULE_(mod,name, MOD,NAME) ...

       These macros mangle four categories of Fortran symbols, respectively:

          - Global symbols without '_': call mysub()
          - Global symbols with '_'   : call my_sub()
          - Module symbols without '_': use mymod; call mysub()
          - Module symbols with '_'   : use mymod; call my_sub()

       If mangling for a category is not known, its macro is left undefined.
       All macros require raw names in both lower case and upper case.  The
       MACRO_NAMESPACE option replaces the default "FortranCInterface_"
       prefix with a given namespace "<macro-ns>".

       The SYMBOLS option lists symbols to mangle automatically with C
       preprocessor definitions:

          <function>          ==> #define <ns><function> ...
          <module>:<function> ==> #define <ns><module>_<function> ...

       If the mangling for some symbol is not known then no preprocessor
       definition is created, and a warning is displayed.  The
       SYMBOL_NAMESPACE option prefixes all preprocessor definitions
       generated by the SYMBOLS option with a given namespace "<ns>".

       Example usage:

          include(FortranCInterface)
          FortranCInterface_HEADER(FC.h MACRO_NAMESPACE "FC_")

       This creates a "FC.h" header that defines mangling macros FC_GLOBAL(),
       FC_GLOBAL_(), FC_MODULE(), and FC_MODULE_().

       Example usage:

          include(FortranCInterface)
          FortranCInterface_HEADER(FCMangle.h
                                   MACRO_NAMESPACE "FC_"
                                   SYMBOL_NAMESPACE "FC_"
                                   SYMBOLS mysub mymod:my_sub)

       This creates a "FC.h" header that defines the same FC_*() mangling
       macros as the previous example plus preprocessor symbols FC_mysub and
       FC_mymod_my_sub.

       Another function is provided to verify that the Fortran and C/C++
       compilers work together:

          FortranCInterface_VERIFY([CXX] [QUIET])

       It tests whether a simple test executable using Fortran and C (and C++
       when the CXX option is given) compiles and links successfully.  The
       result is stored in the cache entry FortranCInterface_VERIFIED_C (or
       FortranCInterface_VERIFIED_CXX if CXX is given) as a boolean.  If the
       check fails and QUIET is not given the function terminates with a
       FATAL_ERROR message describing the problem.  The purpose of this check
       is to stop a build early for incompatible compiler combinations.

       FortranCInterface is aware of possible GLOBAL and MODULE manglings for
       many Fortran compilers, but it also provides an interface to specify
       new possible manglings.  Set the variables

          FortranCInterface_GLOBAL_SYMBOLS
          FortranCInterface_MODULE_SYMBOLS

       before including FortranCInterface to specify manglings of the symbols
       "MySub", "My_Sub", "MyModule:MySub", and "My_Module:My_Sub".  For
       example, the code:

          set(FortranCInterface_GLOBAL_SYMBOLS mysub_ my_sub__ MYSUB_)
            #                                  ^^^^^  ^^^^^^   ^^^^^
          set(FortranCInterface_MODULE_SYMBOLS
              __mymodule_MOD_mysub __my_module_MOD_my_sub)
            #   ^^^^^^^^     ^^^^^   ^^^^^^^^^     ^^^^^^
          include(FortranCInterface)

       tells FortranCInterface to try given GLOBAL and MODULE manglings.
       (The carets point at raw symbol names for clarity in this example but
       are not needed.)

  GetPrerequisites
        

       GetPrerequisites.cmake

       This script provides functions to list the .dll, .dylib or .so files
       that an executable or shared library file depends on.  (Its
       prerequisites.)

       It uses various tools to obtain the list of required shared library
       files:

          dumpbin (Windows)
          ldd (Linux/Unix)
          otool (Mac OSX)

       

       The following functions are provided by this script:

          gp_append_unique
          is_file_executable
          gp_item_default_embedded_path
            (projects can override with gp_item_default_embedded_path_override)
          gp_resolve_item
            (projects can override with gp_resolve_item_override)
          gp_resolved_file_type
          gp_file_type
          get_prerequisites
          list_prerequisites
          list_prerequisites_by_glob

       

       Requires CMake 2.6 or greater because it uses function, break, return
       and PARENT_SCOPE.

  InstallRequiredSystemLibraries
        

       By including this file, all files in the
       CMAKE_INSTALL_DEBUG_LIBRARIES, will be installed with INSTALL_PROGRAMS
       into /bin for WIN32 and /lib for non-win32.  If
       CMAKE_SKIP_INSTALL_RULES is set to TRUE before including this file,
       then the INSTALL command is not called.  The use can use the variable
       CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS to use a custom install command and
       install them into any directory they want.  If it is the MSVC
       compiler, then the microsoft run time libraries will be found add
       automatically added to the CMAKE_INSTALL_DEBUG_LIBRARIES, and
       installed.  If CMAKE_INSTALL_DEBUG_LIBRARIES is set and it is the MSVC
       compiler, then the debug libraries are installed when available.  If
       CMAKE_INSTALL_MFC_LIBRARIES is set then the MFC run time libraries are
       installed as well as the CRT run time libraries.

  MacroAddFileDependencies
       MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...)

       Using the macro MACRO_ADD_FILE_DEPENDENCIES() is discouraged.  There
       are usually better ways to specifiy the correct dependencies.

       MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...) is just a
       convenience wrapper around the OBJECT_DEPENDS source file property.
       You can just use SET_PROPERTY(SOURCE <file> APPEND PROPERTY
       OBJECT_DEPENDS depend_files) instead.

  SelectLibraryConfigurations
        

       select_library_configurations( basename )

       This macro takes a library base name as an argument, and will choose
       good values for basename_LIBRARY, basename_LIBRARIES,
       basename_LIBRARY_DEBUG, and basename_LIBRARY_RELEASE depending on what
       has been found and set.  If only basename_LIBRARY_RELEASE is defined,
       basename_LIBRARY, basename_LIBRARY_DEBUG, and basename_LIBRARY_RELEASE
       will be set to the release value.  If only basename_LIBRARY_DEBUG is
       defined, then basename_LIBRARY, basename_LIBRARY_DEBUG and
       basename_LIBRARY_RELEASE will take the debug value.

       If the generator supports configuration types, then basename_LIBRARY
       and basename_LIBRARIES will be set with debug and optimized flags
       specifying the library to be used for the given configuration.  If no
       build type has been set or the generator in use does not support
       configuration types, then basename_LIBRARY and basename_LIBRARIES will
       take only the release values.

  SquishTestScript
        

       

       This script launches a GUI test using Squish.  You should not call the
       script directly; instead, you should access it via the SQUISH_ADD_TEST
       macro that is defined in FindSquish.cmake.

       This script starts the Squish server, launches the test on the client,
       and finally stops the squish server.  If any of these steps fail
       (including if the tests do not pass) then a fatal error is raised.


  TestBigEndian
       Define macro to determine endian type

       Check if the system is big endian or little endian

         TEST_BIG_ENDIAN(VARIABLE)
         VARIABLE - variable to store the result to

       


  TestCXXAcceptsFlag
       Test CXX compiler for a flag

       Check if the CXX compiler accepts a flag

         Macro CHECK_CXX_ACCEPTS_FLAG(FLAGS VARIABLE) -
            checks if the function exists
         FLAGS - the flags to try
         VARIABLE - variable to store the result

       


  TestForANSIForScope
       Check for ANSI for scope support

       Check if the compiler restricts the scope of variables declared in a
       for-init-statement to the loop body.

         CMAKE_NO_ANSI_FOR_SCOPE - holds result

       


  TestForANSIStreamHeaders
       Test for compiler support of ANSI stream headers iostream, etc.

       check if the compiler supports the standard ANSI iostream header
       (without the .h)

         CMAKE_NO_ANSI_STREAM_HEADERS - defined by the results

       


  TestForSSTREAM
       Test for compiler support of ANSI sstream header

       check if the compiler supports the standard ANSI sstream header

         CMAKE_NO_ANSI_STRING_STREAM - defined by the results

       


  TestForSTDNamespace
       Test for std:: namespace support

       check if the compiler supports std:: on stl classes

         CMAKE_NO_STD_NAMESPACE - defined by the results

       


  UseEcos
       This module defines variables and macros required to build eCos
       application.

       This file contains the following macros:
       ECOS_ADD_INCLUDE_DIRECTORIES() - add the eCos include dirs
       ECOS_ADD_EXECUTABLE(name source1 ...  sourceN ) - create an eCos
       executable ECOS_ADJUST_DIRECTORY(VAR source1 ...  sourceN ) - adjusts
       the path of the source files and puts the result into VAR

       Macros for selecting the toolchain: ECOS_USE_ARM_ELF_TOOLS() - enable
       the ARM ELF toolchain for the directory where it is called
       ECOS_USE_I386_ELF_TOOLS() - enable the i386 ELF toolchain for the
       directory where it is called ECOS_USE_PPC_EABI_TOOLS() - enable the
       PowerPC toolchain for the directory where it is called

       It contains the following variables: ECOS_DEFINITIONS
       ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE - defaults to ecos.ecc, if your
       eCos configuration file has a different name, adjust this variable for
       internal use only:

         ECOS_ADD_TARGET_LIB


  UsePkgConfig
       obsolete pkg-config module for CMake

       

       Defines the following macros:

       PKGCONFIG(package includedir libdir linkflags cflags)

       Calling PKGCONFIG will fill the desired information into the 4 given
       arguments, e.g.  PKGCONFIG(libart-2.0 LIBART_INCLUDE_DIR
       LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS) if pkg-config was NOT
       found or the specified software package doesn't exist, the variable
       will be empty when the function returns, otherwise they will contain
       the respective information


  UseQt4
       Use Module for QT4

       Sets up C and C++ to use Qt 4.  It is assumed that FindQt.cmake has
       already been loaded.  See FindQt.cmake for information on how to load
       Qt 4 into your CMake project.

  UseSWIG
       SWIG module for CMake

       Defines the following macros:

          SWIG_ADD_MODULE(name language [ files ])
            - Define swig module with given name and specified language
          SWIG_LINK_LIBRARIES(name [ libraries ])
            - Link libraries to swig module

       All other macros are for internal use only.  To get the actual name of
       the swig module, use: ${SWIG_MODULE_${name}_REAL_NAME}.  Set Source
       files properties such as CPLUSPLUS and SWIG_FLAGS to specify special
       behavior of SWIG.  Also global CMAKE_SWIG_FLAGS can be used to add
       special flags to all swig calls.  Another special variable is
       CMAKE_SWIG_OUTDIR, it allows one to specify where to write all the
       swig generated module (swig -outdir option) The name-specific variable
       SWIG_MODULE_<name>_EXTRA_DEPS may be used to specify extra
       dependencies for the generated modules.  If the source file generated
       by swig need some special flag you can use
       SET_SOURCE_FILES_PROPERTIES( ${swig_generated_file_fullname}

               PROPERTIES COMPILE_FLAGS "-bla")


  Use_wxWindows
       ---------------------------------------------------

       

       This convenience include finds if wxWindows is installed and set the
       appropriate libs, incdirs, flags etc.  author Jan Woetzel <jw -at-
       mip.informatik.uni-kiel.de> (07/2003)

       USAGE:

          just include Use_wxWindows.cmake
          in your projects CMakeLists.txt

       INCLUDE( ${CMAKE_MODULE_PATH}/Use_wxWindows.cmake)

          if you are sure you need GL then

       SET(WXWINDOWS_USE_GL 1)

          *before* you include this file.


  UsewxWidgets
       Convenience include for using wxWidgets library

       Finds if wxWidgets is installed and set the appropriate libs, incdirs,
       flags etc.  INCLUDE_DIRECTORIES, LINK_DIRECTORIES and ADD_DEFINITIONS
       are called.

       USAGE

         SET( wxWidgets_USE_LIBS  gl xml xrc ) # optionally: more than wx std libs
         FIND_PACKAGE(wxWidgets REQUIRED)
         INCLUDE( ${xWidgets_USE_FILE} )
         ... add your targets here, e.g. ADD_EXECUTABLE/ ADD_LIBRARY ...
         TARGET_LINK_LIBRARIERS( <yourWxDependantTarget>  ${wxWidgets_LIBRARIES})

       

       DEPRECATED

         LINK_LIBRARIES is not called in favor of adding dependencies per target.

       

       AUTHOR

         Jan Woetzel <jw -at- mip.informatik.uni-kiel.de>


------------------------------------------------------------------------------
Copyright

Copyright 2000-2009 Kitware, Inc., Insight Software Consortium.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

Neither the names of Kitware, Inc., the Insight Software Consortium, nor the
names of their contributors may be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

------------------------------------------------------------------------------
See Also

.B ccmake(1), cpack(1), ctest(1), cmakecommands(1), cmakecompat(1),
cmakemodules(1), cmakeprops(1), cmakevars(1)

The following resources are available to get help using CMake:

  Home Page
       http://www.cmake.org

       The primary starting point for learning about CMake.

  Frequently Asked Questions
       http://www.cmake.org/Wiki/CMake_FAQ

       A Wiki is provided containing answers to frequently asked questions.

  Online Documentation
       http://www.cmake.org/HTML/Documentation.html

       Links to available documentation may be found on this web page.

  Mailing List
       http://www.cmake.org/HTML/MailingLists.html

       For help and discussion about using cmake, a mailing list is provided
       at cmake@cmake.org.  The list is member-post-only but one may sign up
       on the CMake web page.  Please first read the full documentation at
       http://www.cmake.org before posting questions to the list.

Summary of helpful links:

  Home: http://www.cmake.org
  Docs: http://www.cmake.org/HTML/Documentation.html
  Mail: http://www.cmake.org/HTML/MailingLists.html
  FAQ:  http://www.cmake.org/Wiki/CMake_FAQ


